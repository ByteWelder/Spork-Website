{
    "docs": [
        {
            "location": "/", 
            "text": "Spork 3.x\n\n\nGetting started\n\n\nAdd the following dependencies in \nbuild.gradle\n:\n\n\ndependencies {\n    // Spork core, including component injection\n    compile 'io.github.sporklibrary:spork:3.2.0'\n    // Spork for Android\n    compile 'io.github.sporklibrary:spork-android:3.0.0@aar'\n    // Optional: Spork Android support/compat library bindings (e.g. support Fragment injection)\n    // It requires you to also add: appcompat-v7, support-v4, recyclerview-v7\n    compile 'io.github.sporklibrary:spork-android-support:3.0.0@aar' \n}\n\n\n\n\nAll dependencies are available at \nMaven Central Repository\n.\n\n\nUpgrading from 2.x to 3.x:\n\n\n\n\nSpork Android has changed its files from \nio.github.sporklibrary\n to \nio.github.sporklibrary.android\n\n\nThere are separate dependencies for the Android support/compat libraries as defined above.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#spork-3x", 
            "text": "", 
            "title": "Spork 3.x"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Add the following dependencies in  build.gradle :  dependencies {\n    // Spork core, including component injection\n    compile 'io.github.sporklibrary:spork:3.2.0'\n    // Spork for Android\n    compile 'io.github.sporklibrary:spork-android:3.0.0@aar'\n    // Optional: Spork Android support/compat library bindings (e.g. support Fragment injection)\n    // It requires you to also add: appcompat-v7, support-v4, recyclerview-v7\n    compile 'io.github.sporklibrary:spork-android-support:3.0.0@aar' \n}  All dependencies are available at  Maven Central Repository .", 
            "title": "Getting started"
        }, 
        {
            "location": "/#upgrading-from-2x-to-3x", 
            "text": "Spork Android has changed its files from  io.github.sporklibrary  to  io.github.sporklibrary.android  There are separate dependencies for the Android support/compat libraries as defined above.", 
            "title": "Upgrading from 2.x to 3.x:"
        }, 
        {
            "location": "/android/annotations/bindclick/", 
            "text": "@BindClick\n\n\nThis annotation can be used with classes derived from:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.app.\nFragment\n\n\nandroid.support.v4.app.\nFragment\n\n\nandroid.support.v7.widget.\nRecyclerView.ViewHolder\n\n\nandroid.view.\nView\n\n\n\n\nYou can specify the view id as the annotation value:\n\n\n@BindClick(R.id.download_button)\nprivate void onClickDownload() {\n}\n\n\n\n\nAlternatively, you can imply the view id by the method name:\n\n\n@BindClick\nprivate void download_button() {\n}\n\n\n\n\nYou can also pass the any compatible View instance as method argument:\n\n\n@BindClick(R.id.download_button)\nprivate void onClickDownload(Button button) {\n}", 
            "title": "@BindClick"
        }, 
        {
            "location": "/android/annotations/bindclick/#bindclick", 
            "text": "This annotation can be used with classes derived from:   android.app. Activity  android.app. Fragment  android.support.v4.app. Fragment  android.support.v7.widget. RecyclerView.ViewHolder  android.view. View   You can specify the view id as the annotation value:  @BindClick(R.id.download_button)\nprivate void onClickDownload() {\n}  Alternatively, you can imply the view id by the method name:  @BindClick\nprivate void download_button() {\n}  You can also pass the any compatible View instance as method argument:  @BindClick(R.id.download_button)\nprivate void onClickDownload(Button button) {\n}", 
            "title": "@BindClick"
        }, 
        {
            "location": "/java/annotations/bindcomponent/", 
            "text": "@BindComponent\n\n\nAny class can become a component.\n\n\nComponents need to have a default constructor available (either specified or implied) with 0 or 1 arguments.\n\n\nComponents don't need to call \nSpork.bind()\n itself, but it is perfectly fine to do so.\n\n\nThis is the simplest component that you could create:\n\n\npublic class Parent {\n    @BindComponent\n    private Child child;\n\n    public Parent() {\n        Spork.bind(this);\n    }\n}\n\npublic class Child {\n}\n\n\n\n\nBase types and interfaces\n\n\nYou can inject to any assignable type, as long as you specify the implementation.\n\n\nFor example:\n\n\n@BindComponent(SomethingImplementation.class)\nprivate SomethingInterface something;\n\n\n\n\nScope\n\n\nYou can optionally specify a scope for \nChild\n by declaring in an annotation.\n\n\nThe default scope means that a new instance of the component is created for each time it is bound somewhere.\n\n\nThe singleton scope means that there will be at most 1 instance.\n\n\n@ComponentScope(ComponentScope.Scope.SINGLETON)\npublic class Child {\n    // ...\n}\n\n\n\n\nParent\n\n\nIf you want to inject the component's parent, you can add it as a constructor parameter.\nIt is also not required to call Spork.bind() on the referenced component.\n\n\nIt's important that you always use the \n@ComponentParent\n annotation on the parameter.\n\n\npublic class Child {\n    final private Parent parent;\n\n    public Child(@ComponentParent Parent parent) {\n        this.parent = parent;\n    }\n}\n\n\n\n\nThe default scope creates a new instance for each binding.", 
            "title": "@BindComponent"
        }, 
        {
            "location": "/java/annotations/bindcomponent/#bindcomponent", 
            "text": "Any class can become a component.  Components need to have a default constructor available (either specified or implied) with 0 or 1 arguments.  Components don't need to call  Spork.bind()  itself, but it is perfectly fine to do so.  This is the simplest component that you could create:  public class Parent {\n    @BindComponent\n    private Child child;\n\n    public Parent() {\n        Spork.bind(this);\n    }\n}\n\npublic class Child {\n}", 
            "title": "@BindComponent"
        }, 
        {
            "location": "/java/annotations/bindcomponent/#base-types-and-interfaces", 
            "text": "You can inject to any assignable type, as long as you specify the implementation.  For example:  @BindComponent(SomethingImplementation.class)\nprivate SomethingInterface something;", 
            "title": "Base types and interfaces"
        }, 
        {
            "location": "/java/annotations/bindcomponent/#scope", 
            "text": "You can optionally specify a scope for  Child  by declaring in an annotation.  The default scope means that a new instance of the component is created for each time it is bound somewhere.  The singleton scope means that there will be at most 1 instance.  @ComponentScope(ComponentScope.Scope.SINGLETON)\npublic class Child {\n    // ...\n}", 
            "title": "Scope"
        }, 
        {
            "location": "/java/annotations/bindcomponent/#parent", 
            "text": "If you want to inject the component's parent, you can add it as a constructor parameter.\nIt is also not required to call Spork.bind() on the referenced component.  It's important that you always use the  @ComponentParent  annotation on the parameter.  public class Child {\n    final private Parent parent;\n\n    public Child(@ComponentParent Parent parent) {\n        this.parent = parent;\n    }\n}  The default scope creates a new instance for each binding.", 
            "title": "Parent"
        }, 
        {
            "location": "/android/annotations/bindfragment/", 
            "text": "@BindFragment\n\n\nThis annotation can be used with classes derived from:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.app.\nFragment\n\n\nandroid.support.v4.app.\nFragment\n\n\n\n\nYou can bind a fragment by specifying its id:\n\n\n@BindFragment(R.id.my_fragment)\nprivate Fragment myFragment;\n\n\n\n\nAlternatively, you can imply the fragment id by the field name:\n\n\n@BindFragment\nprivate Fragment my_fragment;", 
            "title": "@BindFragment"
        }, 
        {
            "location": "/android/annotations/bindfragment/#bindfragment", 
            "text": "This annotation can be used with classes derived from:   android.app. Activity  android.app. Fragment  android.support.v4.app. Fragment   You can bind a fragment by specifying its id:  @BindFragment(R.id.my_fragment)\nprivate Fragment myFragment;  Alternatively, you can imply the fragment id by the field name:  @BindFragment\nprivate Fragment my_fragment;", 
            "title": "@BindFragment"
        }, 
        {
            "location": "/android/annotations/bindlayout/", 
            "text": "@BindLayout\n\n\nThis annotation can be used with classes derived from:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.view.\nViewGroup\n\n\n\n\nWhen using it for \nViewGroup\n, a \nFrameLayout\n is preferred as the inflated layout will be added as a child to it.\n\n\nExample: Activity\n\n\n@BindLayout(R.layout.activity_custom)\npublic class CustomActivity extends Activity {\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this);\n    }\n}\n\n\n\n\nExample: ViewGroup\n\n\n@BindLayout(R.layout.view_custom)\npublic class CustomView extends FrameLayout {\n\n    public MyView(Context context) {\n        super(context);\n        Spork.bind(this);\n    }\n}", 
            "title": "@BindLayout"
        }, 
        {
            "location": "/android/annotations/bindlayout/#bindlayout", 
            "text": "This annotation can be used with classes derived from:   android.app. Activity  android.view. ViewGroup   When using it for  ViewGroup , a  FrameLayout  is preferred as the inflated layout will be added as a child to it.", 
            "title": "@BindLayout"
        }, 
        {
            "location": "/android/annotations/bindlayout/#example-activity", 
            "text": "@BindLayout(R.layout.activity_custom)\npublic class CustomActivity extends Activity {\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this);\n    }\n}", 
            "title": "Example: Activity"
        }, 
        {
            "location": "/android/annotations/bindlayout/#example-viewgroup", 
            "text": "@BindLayout(R.layout.view_custom)\npublic class CustomView extends FrameLayout {\n\n    public MyView(Context context) {\n        super(context);\n        Spork.bind(this);\n    }\n}", 
            "title": "Example: ViewGroup"
        }, 
        {
            "location": "/android/annotations/bindresource/", 
            "text": "@BindResoure\n\n\nThis annotation can be used with classes derived from:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.app.\nApplication\n\n\nandroid.app.\nFragment\n\n\nandroid.app.\nService\n\n\nandroid.content.\nContentProvider\n\n\nandroid.support.v4.app.\nFragment\n\n\nandroid.support.v7.widget.\nRecyclerView.ViewHolder\n\n\nandroid.view.\nView\n\n\nio.github.sporklibrary.interfaces.\nContextProvider\n\n\n\n\nIt can bind:\n\n\n\n\nR.dimen.*\n to \nFloat\n or \nfloat\n fields\n\n\nR.string.*\n to \nString\n fields\n\n\nR.drawable.*\n to \nDrawable\n fields\n\n\n\n\nYou can bind a resource by specifying its id:\n\n\n@BindResource(R.string.app_name)\nprivate String appName;\n\n\n\n\nAlternatively, you can imply the view id by the field name:\n\n\n@BindResource\nprivate String app_name;\n\n\n\n\nExample\n\n\npublic class MyActivity extends Activity {\n\n    @BindResource(R.string.app_name)\n    private String appName;\n\n    @BindResource\n    private String app_name;\n\n    @BindResource(R.dimen.spork_test_dimension)\n    private float sporkTestDimension;\n\n    @BindResource\n    private Float spork_test_dimension;\n\n    @BindResource(R.drawable.spork_test_drawable)\n    private Drawable sporkTestDrawable;\n\n    @BindResource\n    private Drawable spork_test_drawable;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this);\n    }\n}", 
            "title": "@BindResource"
        }, 
        {
            "location": "/android/annotations/bindresource/#bindresoure", 
            "text": "This annotation can be used with classes derived from:   android.app. Activity  android.app. Application  android.app. Fragment  android.app. Service  android.content. ContentProvider  android.support.v4.app. Fragment  android.support.v7.widget. RecyclerView.ViewHolder  android.view. View  io.github.sporklibrary.interfaces. ContextProvider   It can bind:   R.dimen.*  to  Float  or  float  fields  R.string.*  to  String  fields  R.drawable.*  to  Drawable  fields   You can bind a resource by specifying its id:  @BindResource(R.string.app_name)\nprivate String appName;  Alternatively, you can imply the view id by the field name:  @BindResource\nprivate String app_name;", 
            "title": "@BindResoure"
        }, 
        {
            "location": "/android/annotations/bindresource/#example", 
            "text": "public class MyActivity extends Activity {\n\n    @BindResource(R.string.app_name)\n    private String appName;\n\n    @BindResource\n    private String app_name;\n\n    @BindResource(R.dimen.spork_test_dimension)\n    private float sporkTestDimension;\n\n    @BindResource\n    private Float spork_test_dimension;\n\n    @BindResource(R.drawable.spork_test_drawable)\n    private Drawable sporkTestDrawable;\n\n    @BindResource\n    private Drawable spork_test_drawable;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this);\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/android/annotations/bindview/", 
            "text": "@BindView\n\n\nThis annotation can be used with classes derived from:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.app.\nFragment\n\n\nandroid.support.v4.app.\nFragment\n\n\nandroid.support.v7.widget.\nRecyclerView.ViewHolder\n\n\nandroid.view.\nView\n\n\n\n\nYou can bind a view by specifying its id:\n\n\n@BindView(R.id.my_button)\nprivate Button button;\n\n\n\n\nAlternatively, you can imply the view id by the field name:\n\n\n@BindView\nprivate Button my_button;", 
            "title": "@BindView"
        }, 
        {
            "location": "/android/annotations/bindview/#bindview", 
            "text": "This annotation can be used with classes derived from:   android.app. Activity  android.app. Fragment  android.support.v4.app. Fragment  android.support.v7.widget. RecyclerView.ViewHolder  android.view. View   You can bind a view by specifying its id:  @BindView(R.id.my_button)\nprivate Button button;  Alternatively, you can imply the view id by the field name:  @BindView\nprivate Button my_button;", 
            "title": "@BindView"
        }, 
        {
            "location": "/android/examples/application/", 
            "text": "Application\n\n\nIntroduction\n\n\nThe following annotations are supported:\n\n\n\n\n@BindResource\n\n\n@BindComponent\n\n\n\n\nExample\n\n\npublic class MyApplication extends android.app.Application {\n\n    @BindComponent\n    private MyComponent component;\n\n    @BindResource(R.string.app_name)\n    private String appName;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Spork.bind(this);\n    }\n}\n\npublic class MyComponent {\n}", 
            "title": "Application"
        }, 
        {
            "location": "/android/examples/application/#application", 
            "text": "", 
            "title": "Application"
        }, 
        {
            "location": "/android/examples/application/#introduction", 
            "text": "The following annotations are supported:   @BindResource  @BindComponent", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/examples/application/#example", 
            "text": "public class MyApplication extends android.app.Application {\n\n    @BindComponent\n    private MyComponent component;\n\n    @BindResource(R.string.app_name)\n    private String appName;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Spork.bind(this);\n    }\n}\n\npublic class MyComponent {\n}", 
            "title": "Example"
        }, 
        {
            "location": "/android/examples/activity/", 
            "text": "Activity\n\n\nIntroduction\n\n\nBoth \nActivity\n and \nAppCompatActivity\n are supported.\n\n\nThe following annotations are supported:\n\n\n\n\n@BindClick\n\n\n@BindView\n\n\n@BindLayout\n\n\n@BindResource\n\n\n@BindFragment\n\n\n@BindComponent\n\n\n\n\nExample\n\n\n@BindLayout(R.layout.activity_download)\npublic class DownloadActivity extends Activity {\n\n    @BindView(R.id.download_button)\n    private Button downloadButton;\n\n    @BindFragment(R.id.details_fragment)\n    private DetailsFragment fragment;\n\n    @BindComponent\n    private DownloadManager downloadManager;\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this); // Spork does its magic\n    }\n\n    @BindClick(R.id.other_button)\n    private void onClickButton(Button someButton) {\n        downloadManager.startDownload();\n    }\n}\n\n@ComponentScope(scope = ComponentScope.Scope.SINGLETON)\npublic class DownloadManager {\n    public void startDownload() {}\n}", 
            "title": "Activity"
        }, 
        {
            "location": "/android/examples/activity/#activity", 
            "text": "", 
            "title": "Activity"
        }, 
        {
            "location": "/android/examples/activity/#introduction", 
            "text": "Both  Activity  and  AppCompatActivity  are supported.  The following annotations are supported:   @BindClick  @BindView  @BindLayout  @BindResource  @BindFragment  @BindComponent", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/examples/activity/#example", 
            "text": "@BindLayout(R.layout.activity_download)\npublic class DownloadActivity extends Activity {\n\n    @BindView(R.id.download_button)\n    private Button downloadButton;\n\n    @BindFragment(R.id.details_fragment)\n    private DetailsFragment fragment;\n\n    @BindComponent\n    private DownloadManager downloadManager;\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this); // Spork does its magic\n    }\n\n    @BindClick(R.id.other_button)\n    private void onClickButton(Button someButton) {\n        downloadManager.startDownload();\n    }\n}\n\n@ComponentScope(scope = ComponentScope.Scope.SINGLETON)\npublic class DownloadManager {\n    public void startDownload() {}\n}", 
            "title": "Example"
        }, 
        {
            "location": "/java/examples/component/", 
            "text": "Component\n\n\nIntroduction\n\n\nSpork.bind()\n can be used on any \nObject\n to bind components to its fields.\n\n\nA component can be bound directly:\n\n\n@BindComponent\nprivate RegularUserManager regularUserManager;\n\n\n\n\nOr it can be bound by specifying its interface and implementation:\n\n\n@BindComponent(RegularUserManager.class)\nprivate UserManager userManager;\n\n\n\n\nCheck out the \ncomponent documentation\n for more details.\n\n\nExample\n\n\nServices\n\n\npublic interface UserManager {\n    User getUser(long id);\n}\n\n@ComponentScope(ComponentScope.Scope.SINGLETON) // optional annotation\npublic class RegularUserManager implements UserManager\n{\n    public User getUser(long id) {\n        // return user from database\n    }\n}\n\n@ComponentScope(ComponentScope.Scope.SINGLETON) // optional annotation\npublic class CachedUserManager implements UserManager {\n    public User getUser(long id) {\n        // return user from cache\n    }\n}\n\n\n\n\n\nApplication\n\n\npublic class Application implements Runnable {\n\n    @BindComponent(RegularUserManager.class)\n    private UserManager regularUserManager;\n\n    @BindComponent(CachedUserManager.class)\n    private UserManager cachedUserManager;\n\n    public Application() {\n        Spork.bind(this);\n    }\n\n    @Override\n    public void run() {\n        // use regularUserManager and cachedUserManager\n    }\n}", 
            "title": "Component"
        }, 
        {
            "location": "/java/examples/component/#component", 
            "text": "", 
            "title": "Component"
        }, 
        {
            "location": "/java/examples/component/#introduction", 
            "text": "Spork.bind()  can be used on any  Object  to bind components to its fields.  A component can be bound directly:  @BindComponent\nprivate RegularUserManager regularUserManager;  Or it can be bound by specifying its interface and implementation:  @BindComponent(RegularUserManager.class)\nprivate UserManager userManager;  Check out the  component documentation  for more details.", 
            "title": "Introduction"
        }, 
        {
            "location": "/java/examples/component/#example", 
            "text": "Services  public interface UserManager {\n    User getUser(long id);\n}\n\n@ComponentScope(ComponentScope.Scope.SINGLETON) // optional annotation\npublic class RegularUserManager implements UserManager\n{\n    public User getUser(long id) {\n        // return user from database\n    }\n}\n\n@ComponentScope(ComponentScope.Scope.SINGLETON) // optional annotation\npublic class CachedUserManager implements UserManager {\n    public User getUser(long id) {\n        // return user from cache\n    }\n}  Application  public class Application implements Runnable {\n\n    @BindComponent(RegularUserManager.class)\n    private UserManager regularUserManager;\n\n    @BindComponent(CachedUserManager.class)\n    private UserManager cachedUserManager;\n\n    public Application() {\n        Spork.bind(this);\n    }\n\n    @Override\n    public void run() {\n        // use regularUserManager and cachedUserManager\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/android/examples/contentprovider/", 
            "text": "ContentProvider\n\n\nIntroduction\n\n\nThe following annotations are supported:\n\n\n\n\n@BindResource\n\n\n@BindComponent\n\n\n\n\nExample\n\n\npublic class CustomContentProvider extends ContentProvider {\n\n    @BindComponent\n    private SomeComponent component;\n\n    @Override\n    public boolean onCreate() {\n        Spork.bind(this);\n        return true;\n    }\n\n    // ContentProvider methods\n}", 
            "title": "ContentProvider"
        }, 
        {
            "location": "/android/examples/contentprovider/#contentprovider", 
            "text": "", 
            "title": "ContentProvider"
        }, 
        {
            "location": "/android/examples/contentprovider/#introduction", 
            "text": "The following annotations are supported:   @BindResource  @BindComponent", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/examples/contentprovider/#example", 
            "text": "public class CustomContentProvider extends ContentProvider {\n\n    @BindComponent\n    private SomeComponent component;\n\n    @Override\n    public boolean onCreate() {\n        Spork.bind(this);\n        return true;\n    }\n\n    // ContentProvider methods\n}", 
            "title": "Example"
        }, 
        {
            "location": "/android/examples/fragment/", 
            "text": "Fragment\n\n\nIntroduction\n\n\nBoth \nandroid.app.Fragment\n and \nandroid.support.v4.app.Fragment\n are supported.\n\n\nThe following annotations are supported:\n\n\n\n\n@BindClick\n\n\n@BindView\n\n\n@BindResource\n\n\n@BindFragment\n\n\n@BindComponent\n\n\n\n\nExample\n\n\npublic class MyFragment extends Fragment {\n\n    @BindView(R.id.some_textview)\n    private TextView myTextView;\n\n    @Override\n    public View onCreateView(LayoutInflater inflater,\n        @Nullable ViewGroup container, Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_click_binding, container);\n    }\n\n    @Override\n    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {\n        Spork.bind(this);\n    }\n\n    @BindClick(R.id.some_button)\n    private void onClick() {\n        // click-handling code goes here\n    }\n}", 
            "title": "Fragment"
        }, 
        {
            "location": "/android/examples/fragment/#fragment", 
            "text": "", 
            "title": "Fragment"
        }, 
        {
            "location": "/android/examples/fragment/#introduction", 
            "text": "Both  android.app.Fragment  and  android.support.v4.app.Fragment  are supported.  The following annotations are supported:   @BindClick  @BindView  @BindResource  @BindFragment  @BindComponent", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/examples/fragment/#example", 
            "text": "public class MyFragment extends Fragment {\n\n    @BindView(R.id.some_textview)\n    private TextView myTextView;\n\n    @Override\n    public View onCreateView(LayoutInflater inflater,\n        @Nullable ViewGroup container, Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_click_binding, container);\n    }\n\n    @Override\n    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {\n        Spork.bind(this);\n    }\n\n    @BindClick(R.id.some_button)\n    private void onClick() {\n        // click-handling code goes here\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/android/examples/recyclerview/", 
            "text": "RecyclerView\n\n\nIntroduction\n\n\nTo bind \nRecyclerView\n views, you need to bind the \nRecyclerView.ViewHolder\n.\n\n\nThe following annotations are supported:\n\n\n\n\n@BindView\n\n\n@BindClick\n\n\n@BindResource\n\n\n@BindComponent\n\n\n\n\nExample\n\n\npublic class MyAdapter extends RecyclerView.Adapter\nMyAdapter.MyViewHolder\n {\n    private final List\nString\n items;\n\n    public MyAdapter(List\nString\n items) {\n        this.items = items;\n    }\n\n    public class MyViewHolder extends RecyclerView.ViewHolder {\n\n        @BindView(R.id.textview)\n        private TextView textView;\n\n        public MyViewHolder(View itemView) {\n            super(itemView);\n            Spork.bind(this);\n        }\n\n        public void update(String text) {\n            textView.setText(text);\n        }\n\n        @BindClick(R.id.textview)\n        private void onClick() {\n            // Your click-handling logic goes here\n        }\n    }\n\n    @Override\n    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        LayoutInflater inflater = LayoutInflater.from(parent.getContext());\n        View view = inflater.inflate(R.layout.view_recyclerview_item, parent, false);\n        return new MyViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(MyViewHolder holder, int position) {\n        String item = items.get(position);\n        holder.update(item);\n    }\n\n    @Override\n    public int getItemCount() {\n        return items.size();\n    }\n}", 
            "title": "RecyclerView"
        }, 
        {
            "location": "/android/examples/recyclerview/#recyclerview", 
            "text": "", 
            "title": "RecyclerView"
        }, 
        {
            "location": "/android/examples/recyclerview/#introduction", 
            "text": "To bind  RecyclerView  views, you need to bind the  RecyclerView.ViewHolder .  The following annotations are supported:   @BindView  @BindClick  @BindResource  @BindComponent", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/examples/recyclerview/#example", 
            "text": "public class MyAdapter extends RecyclerView.Adapter MyAdapter.MyViewHolder  {\n    private final List String  items;\n\n    public MyAdapter(List String  items) {\n        this.items = items;\n    }\n\n    public class MyViewHolder extends RecyclerView.ViewHolder {\n\n        @BindView(R.id.textview)\n        private TextView textView;\n\n        public MyViewHolder(View itemView) {\n            super(itemView);\n            Spork.bind(this);\n        }\n\n        public void update(String text) {\n            textView.setText(text);\n        }\n\n        @BindClick(R.id.textview)\n        private void onClick() {\n            // Your click-handling logic goes here\n        }\n    }\n\n    @Override\n    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        LayoutInflater inflater = LayoutInflater.from(parent.getContext());\n        View view = inflater.inflate(R.layout.view_recyclerview_item, parent, false);\n        return new MyViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(MyViewHolder holder, int position) {\n        String item = items.get(position);\n        holder.update(item);\n    }\n\n    @Override\n    public int getItemCount() {\n        return items.size();\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/android/examples/service/", 
            "text": "Service\n\n\nIntroduction\n\n\nThe following annotations are supported:\n\n\n\n\n@BindResource\n\n\n@BindComponent\n\n\n\n\nExample\n\n\npublic class TestService extends Service {\n    @BindComponent\n    private TestComponent testComponent;\n\n    public class LocalBinder extends Binder {\n        public TestService getLocalService() {\n            return TestService.this;\n        }\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Spork.bind(this);\n    }\n\n    @Override\n    public @Nullable IBinder onBind(Intent intent) {\n        return new LocalBinder();\n    }\n}", 
            "title": "Service"
        }, 
        {
            "location": "/android/examples/service/#service", 
            "text": "", 
            "title": "Service"
        }, 
        {
            "location": "/android/examples/service/#introduction", 
            "text": "The following annotations are supported:   @BindResource  @BindComponent", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/examples/service/#example", 
            "text": "public class TestService extends Service {\n    @BindComponent\n    private TestComponent testComponent;\n\n    public class LocalBinder extends Binder {\n        public TestService getLocalService() {\n            return TestService.this;\n        }\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Spork.bind(this);\n    }\n\n    @Override\n    public @Nullable IBinder onBind(Intent intent) {\n        return new LocalBinder();\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/android/examples/view/", 
            "text": "View\n\n\nIntroduction\n\n\nWhen creating a custom view, it's best to extend a \nFrameLayout\n, because \n@BindLayout\n will inflate the specified layout into it.\n\n\nThe following annotations are supported:\n\n\n\n\n@BindClick\n\n\n@BindView\n\n\n@BindLayout\n\n\n@BindResource\n\n\n@BindComponent\n\n\n\n\nExample\n\n\n@BindLayout(R.layout.view_layout_binding)\npublic class MyView extends FrameLayout {\n\n    @BindView(R.id.some_textview)\n    private TextView textView;\n\n    @BindComponent\n    private DownloadManager downloadManager;\n\n    public MyView(Context context) {\n        super(context);\n        // Note: Spork.bind() must be called in \n        // all constructors that are implemented!\n        Spork.bind(this);\n    }\n\n    @BindClick(R.id.download_button)\n    private void onClickDownload() {\n        downloadManager.startDownload();\n    }\n\n    // BindClick can also pass the button that was clicked\n    @BindClick(R.id.other_button)\n    private void onClickOtherButton(Button otherButton) {\n        downloadManager.startDownload();\n    }\n}", 
            "title": "View"
        }, 
        {
            "location": "/android/examples/view/#view", 
            "text": "", 
            "title": "View"
        }, 
        {
            "location": "/android/examples/view/#introduction", 
            "text": "When creating a custom view, it's best to extend a  FrameLayout , because  @BindLayout  will inflate the specified layout into it.  The following annotations are supported:   @BindClick  @BindView  @BindLayout  @BindResource  @BindComponent", 
            "title": "Introduction"
        }, 
        {
            "location": "/android/examples/view/#example", 
            "text": "@BindLayout(R.layout.view_layout_binding)\npublic class MyView extends FrameLayout {\n\n    @BindView(R.id.some_textview)\n    private TextView textView;\n\n    @BindComponent\n    private DownloadManager downloadManager;\n\n    public MyView(Context context) {\n        super(context);\n        // Note: Spork.bind() must be called in \n        // all constructors that are implemented!\n        Spork.bind(this);\n    }\n\n    @BindClick(R.id.download_button)\n    private void onClickDownload() {\n        downloadManager.startDownload();\n    }\n\n    // BindClick can also pass the button that was clicked\n    @BindClick(R.id.other_button)\n    private void onClickOtherButton(Button otherButton) {\n        downloadManager.startDownload();\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/java/testing/", 
            "text": "Testing\n\n\nSpork provides basic support for unit-testing. Specifically for creating mock/stub classes for components.\n\n\nStandard mocking\n\n\nThe default implementation for mocks/stubs with Spork is by injecting alternative classes into objects:\n\n\n// Create a ComponentFactory for mocking\nMockingComponentFactory mockingFactory = new MockingComponentFactory()\n    .register(RegularImplementationA.class, MockedImplementationA.class)\n    .register(RegularImplementationB.class, MockedImplementationB.class);\n\n// Assign the new ComponentFactory\nComponentInstanceManager.setComponentFactory(mockingFactory);\n\n\n\n\nThat's it! Instead of injecting \nRegularImplementation*\n classes, \nMockedImplementation*\n classes will be instantiated and injected instead!\n\n\nMockito support\n\n\nConfiguration\n\n\nTo enable Mockito support, add the following dependency:\n\n\ndependencies {\n    compile ('io.github.sporklibrary:spork-mockito:1.1.0') {\n        exclude group: 'io.github.sporklibrary'\n    }\n}\n\n\n\n\nExample\n\n\nConsider the following classes:\n\n\npublic class Component {\n\n    public int getValue() {\n        return 1;\n    }\n}\n\npublic class Parent {\n\n    @BindComponent\n    private Component component;\n\n    public Parent() {\n        Spork.bind(this);\n    }\n\n    public Component getComponent() {\n        return component;\n    }\n}\n\n\n\n\nTo start mocking, this needs to be done:\n\n\n// Enable mocking for the specified class(es)\nSporkMockito.initialize(Component.class);\n// This can be called multiple times to reset the mocking classes.\n// Alternatively, mocking can be enabled for all component classes with:\n// SporkMockito.initialize()\n\n// Object instantiation\nParent parent = new Parent();\nComponent mockedComponent = parent.getComponent();\n\n// Run Mockito tests\nassertEquals(\nmocked default value\n, 0, mockedComponent.getValue());\nwhen(mockedComponent.getValue()).thenReturn(2);\nassertEquals(\nmocked overridden value\n, 2, mockedComponent.getValue());\n\n\n\n\nCustom mocking\n\n\nIt's possible to implement your own mocking behavior.\n\n\nAll you need to do is implement your own \nComponentFactory\n and implement the required methods:\n\n\npublic class CustomMockingComponentFactory implements ComponentFactory {\n\n    @Override\n    public Object create(Class\n?\n classObject, Object parent) {\n        return CustomMockingFramework.mock(classObject);\n    }\n}\n\n\n\n\nAll that is left is registering it:\n\n\nComponentInstanceManager.setComponentFactory(customComponentFactory);", 
            "title": "Testing"
        }, 
        {
            "location": "/java/testing/#testing", 
            "text": "Spork provides basic support for unit-testing. Specifically for creating mock/stub classes for components.", 
            "title": "Testing"
        }, 
        {
            "location": "/java/testing/#standard-mocking", 
            "text": "The default implementation for mocks/stubs with Spork is by injecting alternative classes into objects:  // Create a ComponentFactory for mocking\nMockingComponentFactory mockingFactory = new MockingComponentFactory()\n    .register(RegularImplementationA.class, MockedImplementationA.class)\n    .register(RegularImplementationB.class, MockedImplementationB.class);\n\n// Assign the new ComponentFactory\nComponentInstanceManager.setComponentFactory(mockingFactory);  That's it! Instead of injecting  RegularImplementation*  classes,  MockedImplementation*  classes will be instantiated and injected instead!", 
            "title": "Standard mocking"
        }, 
        {
            "location": "/java/testing/#mockito-support", 
            "text": "", 
            "title": "Mockito support"
        }, 
        {
            "location": "/java/testing/#configuration", 
            "text": "To enable Mockito support, add the following dependency:  dependencies {\n    compile ('io.github.sporklibrary:spork-mockito:1.1.0') {\n        exclude group: 'io.github.sporklibrary'\n    }\n}", 
            "title": "Configuration"
        }, 
        {
            "location": "/java/testing/#example", 
            "text": "Consider the following classes:  public class Component {\n\n    public int getValue() {\n        return 1;\n    }\n}\n\npublic class Parent {\n\n    @BindComponent\n    private Component component;\n\n    public Parent() {\n        Spork.bind(this);\n    }\n\n    public Component getComponent() {\n        return component;\n    }\n}  To start mocking, this needs to be done:  // Enable mocking for the specified class(es)\nSporkMockito.initialize(Component.class);\n// This can be called multiple times to reset the mocking classes.\n// Alternatively, mocking can be enabled for all component classes with:\n// SporkMockito.initialize()\n\n// Object instantiation\nParent parent = new Parent();\nComponent mockedComponent = parent.getComponent();\n\n// Run Mockito tests\nassertEquals( mocked default value , 0, mockedComponent.getValue());\nwhen(mockedComponent.getValue()).thenReturn(2);\nassertEquals( mocked overridden value , 2, mockedComponent.getValue());", 
            "title": "Example"
        }, 
        {
            "location": "/java/testing/#custom-mocking", 
            "text": "It's possible to implement your own mocking behavior.  All you need to do is implement your own  ComponentFactory  and implement the required methods:  public class CustomMockingComponentFactory implements ComponentFactory {\n\n    @Override\n    public Object create(Class ?  classObject, Object parent) {\n        return CustomMockingFramework.mock(classObject);\n    }\n}  All that is left is registering it:  ComponentInstanceManager.setComponentFactory(customComponentFactory);", 
            "title": "Custom mocking"
        }, 
        {
            "location": "/java/advanced/creating-annotations/", 
            "text": "Creating Annotations\n\n\nOverview\n\n\nSpork annotations are bound through a \nMethodBinder\n and/or \nFieldBinder\n and/or \nTypeBinder\n.\n\n\nThese binders are registered through a \nBinderManager\n which is accessible through \nSpork.getBinderManager()\n\n\nFieldBinder\n\n\nFieldBinders are used for annotations that target \nElementType.FIELD\n.\n\n\nExample\n\n\npublic class BindViewBinder implements FieldBinder\nBindView\n {\n\n    @Override\n    public Class\nBindView\n getAnnotationClass() {\n        return BindView.class;\n    }\n\n    @Override\n    public void bind(final Object object, final AnnotatedField\nBindView\n annotatedField) {\n        // Internally retrieves a `View` from the `object`\n        // by checking its type (Activity/Fragment/View)\n        final @Nullable View view = resolveView(object, annotatedField);\n\n        if (view == null) {\n            throw new BindException(...);\n        }\n\n        // Set the value for the object given the AnnotatedField\n        AnnotatedFields.set(annotatedField, object, view);\n    }\n}\n\n\n\n\nCheck out the \n@BindView\n annotation binder: \nBindViewBinder\n \nhere\n.\n\n\nMethodBinder\n\n\nMethodBinders are used for annotations that target \nElementType.METHOD\n.\n\n\nExample\n\n\npublic class BindClickBinder implements MethodBinder\nBindClick\n {\n\n    @Override\n    public Class\nBindClick\n getAnnotationClass() {\n        return BindClick.class;\n    }\n\n    @Override\n    public void bind(final Object object, AnnotatedMethod\nBindClick\n annotatedMethod) {\n        // Internally retrieves a 'View' from the `object`\n        // by checking its type (Activity/Fragment/View)\n        final @Nullable View view = getView(object, annotatedMethod);\n\n        if (view == null) {\n            throw new BindException(...);\n        }\n\n        // Bind the custom OnClickListener that applies Java reflection\n        // This saves CPU-intensive reflection calls until when it's necessary\n        view.setOnClickListener(new CustomListener(annotatedMethod, object));\n    }\n}\n\n\n\n\nCheck out the \n@BindClick\n annotation binder: \nBindClickBinder\n \nhere\n.\n\n\nTypeBinder\n\n\nTypeBinders are used for annotations that target \nElementType.TYPE\n.\n\n\nExample\n\n\npublic interface IntSettable {\n    void setValue(int value);\n}\n\npublic class ValueBinder implements TypeBinder\nBindValue\n {\n\n    @Override\n    public Class\nBindValue\n getAnnotationClass() {\n        return BindValue.class;\n    }\n\n    @Override\n    public void bind(Object object, AnnotatedType\nBindValue\n annotatedClass) {\n        // @BindValue only works with IntSettable implementations\n        if (!IntSettable.class.isAssignableFrom(object.getClass())) {\n            throw new BindException(...);\n        }\n\n        // Safely convert to IntSettable\n        IntSettable value_holder = (IntSettable)object;\n\n        // Set the integer value\n        int value = annotatedClass.getAnnotation().value();\n        value_holder.setValue(value);\n    }\n}\n\n\n\n\n\nCheck out the \n@BindLayout\n annotation binder: \nBindLayoutBinder\n \nhere\n.\n\n\nBinder registration\n\n\nSingle target binders\n\n\nFor binders that only bind to a single annotation target (e.g. \nElementType.FIELD\n, \nElementType.METHOD\n or \nElementType.TYPE\n). The following code demonstrates this.\n\n\nYourAnnotation.java\n\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface YourAnnotation {\n}\n\n\n\n\nYourAnnotationBinder.java\n\n\nclass YourAnnotationBinder implements MethodBinder\nYourAnnotation\n {\n    // implementation\n}\n\n\n\n\nMain.java\n\n\nSpork.getBinderManager().register(new YourAnnotationBinder());\n\n\n\n\nMulti-target binders\n\n\nFor binders that only bind to multiple annotation targets (e.g. \nElementType.FIELD\n, \nElementType.METHOD\n or \nElementType.TYPE\n). The following code demonstrates this.\n\n\nYourAnnotation.java\n\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD, Element.FIELD })\npublic @interface YourAnnotation {\n}\n\n\n\n\nYourAnnotationBinder.java\n\n\nclass YourAnnotationBinder\n    implements MethodBinder\nYourAnnotation\n, FieldBinder\nYourAnnotation\n {\n    // implementation\n}\n\n\n\n\nMain.java\n\n\nYourAnnotationBinder binder = new YourAnnotationBinder();\n\n// register as MethodBinder\nSpork.getBinderManager().register((MethodBinder\nYourAnnotation\n)binder);\n// register as FieldBinder\nSpork.getBinderManager().register((FieldBinder\nYourAnnotation\n)binder);", 
            "title": "Creating Annotations"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#creating-annotations", 
            "text": "", 
            "title": "Creating Annotations"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#overview", 
            "text": "Spork annotations are bound through a  MethodBinder  and/or  FieldBinder  and/or  TypeBinder .  These binders are registered through a  BinderManager  which is accessible through  Spork.getBinderManager()", 
            "title": "Overview"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#fieldbinder", 
            "text": "FieldBinders are used for annotations that target  ElementType.FIELD .", 
            "title": "FieldBinder"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#example", 
            "text": "public class BindViewBinder implements FieldBinder BindView  {\n\n    @Override\n    public Class BindView  getAnnotationClass() {\n        return BindView.class;\n    }\n\n    @Override\n    public void bind(final Object object, final AnnotatedField BindView  annotatedField) {\n        // Internally retrieves a `View` from the `object`\n        // by checking its type (Activity/Fragment/View)\n        final @Nullable View view = resolveView(object, annotatedField);\n\n        if (view == null) {\n            throw new BindException(...);\n        }\n\n        // Set the value for the object given the AnnotatedField\n        AnnotatedFields.set(annotatedField, object, view);\n    }\n}  Check out the  @BindView  annotation binder:  BindViewBinder   here .", 
            "title": "Example"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#methodbinder", 
            "text": "MethodBinders are used for annotations that target  ElementType.METHOD .", 
            "title": "MethodBinder"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#example_1", 
            "text": "public class BindClickBinder implements MethodBinder BindClick  {\n\n    @Override\n    public Class BindClick  getAnnotationClass() {\n        return BindClick.class;\n    }\n\n    @Override\n    public void bind(final Object object, AnnotatedMethod BindClick  annotatedMethod) {\n        // Internally retrieves a 'View' from the `object`\n        // by checking its type (Activity/Fragment/View)\n        final @Nullable View view = getView(object, annotatedMethod);\n\n        if (view == null) {\n            throw new BindException(...);\n        }\n\n        // Bind the custom OnClickListener that applies Java reflection\n        // This saves CPU-intensive reflection calls until when it's necessary\n        view.setOnClickListener(new CustomListener(annotatedMethod, object));\n    }\n}  Check out the  @BindClick  annotation binder:  BindClickBinder   here .", 
            "title": "Example"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#typebinder", 
            "text": "TypeBinders are used for annotations that target  ElementType.TYPE .", 
            "title": "TypeBinder"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#example_2", 
            "text": "public interface IntSettable {\n    void setValue(int value);\n}\n\npublic class ValueBinder implements TypeBinder BindValue  {\n\n    @Override\n    public Class BindValue  getAnnotationClass() {\n        return BindValue.class;\n    }\n\n    @Override\n    public void bind(Object object, AnnotatedType BindValue  annotatedClass) {\n        // @BindValue only works with IntSettable implementations\n        if (!IntSettable.class.isAssignableFrom(object.getClass())) {\n            throw new BindException(...);\n        }\n\n        // Safely convert to IntSettable\n        IntSettable value_holder = (IntSettable)object;\n\n        // Set the integer value\n        int value = annotatedClass.getAnnotation().value();\n        value_holder.setValue(value);\n    }\n}  Check out the  @BindLayout  annotation binder:  BindLayoutBinder   here .", 
            "title": "Example"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#binder-registration", 
            "text": "", 
            "title": "Binder registration"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#single-target-binders", 
            "text": "For binders that only bind to a single annotation target (e.g.  ElementType.FIELD ,  ElementType.METHOD  or  ElementType.TYPE ). The following code demonstrates this.  YourAnnotation.java  @Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface YourAnnotation {\n}  YourAnnotationBinder.java  class YourAnnotationBinder implements MethodBinder YourAnnotation  {\n    // implementation\n}  Main.java  Spork.getBinderManager().register(new YourAnnotationBinder());", 
            "title": "Single target binders"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#multi-target-binders", 
            "text": "For binders that only bind to multiple annotation targets (e.g.  ElementType.FIELD ,  ElementType.METHOD  or  ElementType.TYPE ). The following code demonstrates this.  YourAnnotation.java  @Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD, Element.FIELD })\npublic @interface YourAnnotation {\n}  YourAnnotationBinder.java  class YourAnnotationBinder\n    implements MethodBinder YourAnnotation , FieldBinder YourAnnotation  {\n    // implementation\n}  Main.java  YourAnnotationBinder binder = new YourAnnotationBinder();\n\n// register as MethodBinder\nSpork.getBinderManager().register((MethodBinder YourAnnotation )binder);\n// register as FieldBinder\nSpork.getBinderManager().register((FieldBinder YourAnnotation )binder);", 
            "title": "Multi-target binders"
        }, 
        {
            "location": "/android/advanced/proguard/", 
            "text": "ProGuard\n\n\nProGuard's shrinking process might remove your components, because they are instantiated by reflection instead of the regular way. To avoid this, you need to specify the classes and interfaces to keep in your proguard configuration.\n\n\nExample\n\n\n-keep class com.yourapp.components.** { *; }\n-keep interface com.yourapp.components.** { *; }", 
            "title": "ProGuard"
        }, 
        {
            "location": "/android/advanced/proguard/#proguard", 
            "text": "ProGuard's shrinking process might remove your components, because they are instantiated by reflection instead of the regular way. To avoid this, you need to specify the classes and interfaces to keep in your proguard configuration.", 
            "title": "ProGuard"
        }, 
        {
            "location": "/android/advanced/proguard/#example", 
            "text": "-keep class com.yourapp.components.** { *; }\n-keep interface com.yourapp.components.** { *; }", 
            "title": "Example"
        }, 
        {
            "location": "/android/advanced/binding-order/", 
            "text": "Binding Order\n\n\nComponents are bound by the order they are registered in. This means that components are bound first and any other registered annotations are bound after that.\n\n\nComponents\n\n\nWhen \nSpork.bind()\n is called, the \n@BindComponent\n annotations are processed first. This means that when the component is bound, the \n@ComponentParent\n passed in the constructor can be acccessed, but the injection on \n@ComponentParent\n fields might not have finished.\n\n\nExample\n\n\npublic class ExampleActivity extends Activity {\n\n    @BindComponent\n    private Component component;\n\n    @BindView(R.id.test)\n    private View testView;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Spork.bind(this);\n    }\n\n    public View getTestView() {\n        return testView;\n    }\n}\n\npublic class Component {\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        // at this point, activity.getView() will still return null\n    }\n}\n\n\n\n\nSolution 1\n\n\nStore the component parent and access its properties only by reference.\n\n\npublic class ExampleActivity extends Activity {\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void show() {\n        // as long as show() is called after the parent's\n        // Spork.bind() then all is fine\n        activity.getView().setVisibility(View.VISIBLE);\n    }\n}\n\n\n\n\nSolution 2\n\n\nCache the fields when any of the component methods are called.\n\n\npublic class ExampleActivity extends Activity {\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n    private View view;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void show() {\n        assureViewsCached();\n        view.setVisibility(View.VISIBLE);\n    }\n\n    private void assureViewsCached() {\n        if (view == null) {\n            view = activity.getView();\n        }\n    }\n}\n\n\n\n\nSolution 3\n\n\nGive your component an initializing method and call it after the parent's \nSpork.bind()\n\n\npublic class ExampleActivity extends Activity {\n    // ...\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Spork.bind(this);\n\n        component.initialize(); // initialization after binding finished\n    }\n\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n    private View view;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void initialize() {\n        // Cache view\n        view = activity.getView();\n    }\n}\n\n\n\n\nInheritance\n\n\nWhen extending classes, you should only call \nSpork.bind()\n in the base class where you want to apply bindings. All derived classes will automatically get bound too.\n\n\nInjection for classes that apply inheritance happens from the most top-level class to the bottom level base class.\n\n\nclass ComponentBase {\n    public ComponentBase() {\n        Spork.bind(this);\n    }\n}\n\nclass Component extends ComponentBase {\n    @BindComponent\n    private SomeOtherComponent someOtherComponent;\n\n    // No need to call Spork.bind() because superclass handles that\n}\n\nclass Parent {\n    @BindComponent\n    private Component component;\n\n    public Parent() {\n        // Component is injected and both Component and ComponentBase\n        // annotations are processed\n        Spork.bind(this);\n    }\n}", 
            "title": "Binding order"
        }, 
        {
            "location": "/android/advanced/binding-order/#binding-order", 
            "text": "Components are bound by the order they are registered in. This means that components are bound first and any other registered annotations are bound after that.", 
            "title": "Binding Order"
        }, 
        {
            "location": "/android/advanced/binding-order/#components", 
            "text": "When  Spork.bind()  is called, the  @BindComponent  annotations are processed first. This means that when the component is bound, the  @ComponentParent  passed in the constructor can be acccessed, but the injection on  @ComponentParent  fields might not have finished.", 
            "title": "Components"
        }, 
        {
            "location": "/android/advanced/binding-order/#example", 
            "text": "public class ExampleActivity extends Activity {\n\n    @BindComponent\n    private Component component;\n\n    @BindView(R.id.test)\n    private View testView;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Spork.bind(this);\n    }\n\n    public View getTestView() {\n        return testView;\n    }\n}\n\npublic class Component {\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        // at this point, activity.getView() will still return null\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/android/advanced/binding-order/#solution-1", 
            "text": "Store the component parent and access its properties only by reference.  public class ExampleActivity extends Activity {\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void show() {\n        // as long as show() is called after the parent's\n        // Spork.bind() then all is fine\n        activity.getView().setVisibility(View.VISIBLE);\n    }\n}", 
            "title": "Solution 1"
        }, 
        {
            "location": "/android/advanced/binding-order/#solution-2", 
            "text": "Cache the fields when any of the component methods are called.  public class ExampleActivity extends Activity {\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n    private View view;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void show() {\n        assureViewsCached();\n        view.setVisibility(View.VISIBLE);\n    }\n\n    private void assureViewsCached() {\n        if (view == null) {\n            view = activity.getView();\n        }\n    }\n}", 
            "title": "Solution 2"
        }, 
        {
            "location": "/android/advanced/binding-order/#solution-3", 
            "text": "Give your component an initializing method and call it after the parent's  Spork.bind()  public class ExampleActivity extends Activity {\n    // ...\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Spork.bind(this);\n\n        component.initialize(); // initialization after binding finished\n    }\n\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n    private View view;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void initialize() {\n        // Cache view\n        view = activity.getView();\n    }\n}", 
            "title": "Solution 3"
        }, 
        {
            "location": "/android/advanced/binding-order/#inheritance", 
            "text": "When extending classes, you should only call  Spork.bind()  in the base class where you want to apply bindings. All derived classes will automatically get bound too.  Injection for classes that apply inheritance happens from the most top-level class to the bottom level base class.  class ComponentBase {\n    public ComponentBase() {\n        Spork.bind(this);\n    }\n}\n\nclass Component extends ComponentBase {\n    @BindComponent\n    private SomeOtherComponent someOtherComponent;\n\n    // No need to call Spork.bind() because superclass handles that\n}\n\nclass Parent {\n    @BindComponent\n    private Component component;\n\n    public Parent() {\n        // Component is injected and both Component and ComponentBase\n        // annotations are processed\n        Spork.bind(this);\n    }\n}", 
            "title": "Inheritance"
        }, 
        {
            "location": "/java/annotations/bindcomponent/", 
            "text": "@BindComponent\n\n\nAny class can become a component.\n\n\nComponents need to have a default constructor available (either specified or implied) with 0 or 1 arguments.\n\n\nComponents don't need to call \nSpork.bind()\n itself, but it is perfectly fine to do so.\n\n\nThis is the simplest component that you could create:\n\n\npublic class Parent {\n    @BindComponent\n    private Child child;\n\n    public Parent() {\n        Spork.bind(this);\n    }\n}\n\npublic class Child {\n}\n\n\n\n\nBase types and interfaces\n\n\nYou can inject to any assignable type, as long as you specify the implementation.\n\n\nFor example:\n\n\n@BindComponent(SomethingImplementation.class)\nprivate SomethingInterface something;\n\n\n\n\nScope\n\n\nYou can optionally specify a scope for \nChild\n by declaring in an annotation.\n\n\nThe default scope means that a new instance of the component is created for each time it is bound somewhere.\n\n\nThe singleton scope means that there will be at most 1 instance.\n\n\n@ComponentScope(ComponentScope.Scope.SINGLETON)\npublic class Child {\n    // ...\n}\n\n\n\n\nParent\n\n\nIf you want to inject the component's parent, you can add it as a constructor parameter.\nIt is also not required to call Spork.bind() on the referenced component.\n\n\nIt's important that you always use the \n@ComponentParent\n annotation on the parameter.\n\n\npublic class Child {\n    final private Parent parent;\n\n    public Child(@ComponentParent Parent parent) {\n        this.parent = parent;\n    }\n}\n\n\n\n\nThe default scope creates a new instance for each binding.", 
            "title": "@BindComponent"
        }, 
        {
            "location": "/java/annotations/bindcomponent/#bindcomponent", 
            "text": "Any class can become a component.  Components need to have a default constructor available (either specified or implied) with 0 or 1 arguments.  Components don't need to call  Spork.bind()  itself, but it is perfectly fine to do so.  This is the simplest component that you could create:  public class Parent {\n    @BindComponent\n    private Child child;\n\n    public Parent() {\n        Spork.bind(this);\n    }\n}\n\npublic class Child {\n}", 
            "title": "@BindComponent"
        }, 
        {
            "location": "/java/annotations/bindcomponent/#base-types-and-interfaces", 
            "text": "You can inject to any assignable type, as long as you specify the implementation.  For example:  @BindComponent(SomethingImplementation.class)\nprivate SomethingInterface something;", 
            "title": "Base types and interfaces"
        }, 
        {
            "location": "/java/annotations/bindcomponent/#scope", 
            "text": "You can optionally specify a scope for  Child  by declaring in an annotation.  The default scope means that a new instance of the component is created for each time it is bound somewhere.  The singleton scope means that there will be at most 1 instance.  @ComponentScope(ComponentScope.Scope.SINGLETON)\npublic class Child {\n    // ...\n}", 
            "title": "Scope"
        }, 
        {
            "location": "/java/annotations/bindcomponent/#parent", 
            "text": "If you want to inject the component's parent, you can add it as a constructor parameter.\nIt is also not required to call Spork.bind() on the referenced component.  It's important that you always use the  @ComponentParent  annotation on the parameter.  public class Child {\n    final private Parent parent;\n\n    public Child(@ComponentParent Parent parent) {\n        this.parent = parent;\n    }\n}  The default scope creates a new instance for each binding.", 
            "title": "Parent"
        }, 
        {
            "location": "/java/examples/component/", 
            "text": "Component\n\n\nIntroduction\n\n\nSpork.bind()\n can be used on any \nObject\n to bind components to its fields.\n\n\nA component can be bound directly:\n\n\n@BindComponent\nprivate RegularUserManager regularUserManager;\n\n\n\n\nOr it can be bound by specifying its interface and implementation:\n\n\n@BindComponent(RegularUserManager.class)\nprivate UserManager userManager;\n\n\n\n\nCheck out the \ncomponent documentation\n for more details.\n\n\nExample\n\n\nServices\n\n\npublic interface UserManager {\n    User getUser(long id);\n}\n\n@ComponentScope(ComponentScope.Scope.SINGLETON) // optional annotation\npublic class RegularUserManager implements UserManager\n{\n    public User getUser(long id) {\n        // return user from database\n    }\n}\n\n@ComponentScope(ComponentScope.Scope.SINGLETON) // optional annotation\npublic class CachedUserManager implements UserManager {\n    public User getUser(long id) {\n        // return user from cache\n    }\n}\n\n\n\n\n\nApplication\n\n\npublic class Application implements Runnable {\n\n    @BindComponent(RegularUserManager.class)\n    private UserManager regularUserManager;\n\n    @BindComponent(CachedUserManager.class)\n    private UserManager cachedUserManager;\n\n    public Application() {\n        Spork.bind(this);\n    }\n\n    @Override\n    public void run() {\n        // use regularUserManager and cachedUserManager\n    }\n}", 
            "title": "Component"
        }, 
        {
            "location": "/java/examples/component/#component", 
            "text": "", 
            "title": "Component"
        }, 
        {
            "location": "/java/examples/component/#introduction", 
            "text": "Spork.bind()  can be used on any  Object  to bind components to its fields.  A component can be bound directly:  @BindComponent\nprivate RegularUserManager regularUserManager;  Or it can be bound by specifying its interface and implementation:  @BindComponent(RegularUserManager.class)\nprivate UserManager userManager;  Check out the  component documentation  for more details.", 
            "title": "Introduction"
        }, 
        {
            "location": "/java/examples/component/#example", 
            "text": "Services  public interface UserManager {\n    User getUser(long id);\n}\n\n@ComponentScope(ComponentScope.Scope.SINGLETON) // optional annotation\npublic class RegularUserManager implements UserManager\n{\n    public User getUser(long id) {\n        // return user from database\n    }\n}\n\n@ComponentScope(ComponentScope.Scope.SINGLETON) // optional annotation\npublic class CachedUserManager implements UserManager {\n    public User getUser(long id) {\n        // return user from cache\n    }\n}  Application  public class Application implements Runnable {\n\n    @BindComponent(RegularUserManager.class)\n    private UserManager regularUserManager;\n\n    @BindComponent(CachedUserManager.class)\n    private UserManager cachedUserManager;\n\n    public Application() {\n        Spork.bind(this);\n    }\n\n    @Override\n    public void run() {\n        // use regularUserManager and cachedUserManager\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/java/testing/", 
            "text": "Testing\n\n\nSpork provides basic support for unit-testing. Specifically for creating mock/stub classes for components.\n\n\nStandard mocking\n\n\nThe default implementation for mocks/stubs with Spork is by injecting alternative classes into objects:\n\n\n// Create a ComponentFactory for mocking\nMockingComponentFactory mockingFactory = new MockingComponentFactory()\n    .register(RegularImplementationA.class, MockedImplementationA.class)\n    .register(RegularImplementationB.class, MockedImplementationB.class);\n\n// Assign the new ComponentFactory\nComponentInstanceManager.setComponentFactory(mockingFactory);\n\n\n\n\nThat's it! Instead of injecting \nRegularImplementation*\n classes, \nMockedImplementation*\n classes will be instantiated and injected instead!\n\n\nMockito support\n\n\nConfiguration\n\n\nTo enable Mockito support, add the following dependency:\n\n\ndependencies {\n    compile ('io.github.sporklibrary:spork-mockito:1.1.0') {\n        exclude group: 'io.github.sporklibrary'\n    }\n}\n\n\n\n\nExample\n\n\nConsider the following classes:\n\n\npublic class Component {\n\n    public int getValue() {\n        return 1;\n    }\n}\n\npublic class Parent {\n\n    @BindComponent\n    private Component component;\n\n    public Parent() {\n        Spork.bind(this);\n    }\n\n    public Component getComponent() {\n        return component;\n    }\n}\n\n\n\n\nTo start mocking, this needs to be done:\n\n\n// Enable mocking for the specified class(es)\nSporkMockito.initialize(Component.class);\n// This can be called multiple times to reset the mocking classes.\n// Alternatively, mocking can be enabled for all component classes with:\n// SporkMockito.initialize()\n\n// Object instantiation\nParent parent = new Parent();\nComponent mockedComponent = parent.getComponent();\n\n// Run Mockito tests\nassertEquals(\nmocked default value\n, 0, mockedComponent.getValue());\nwhen(mockedComponent.getValue()).thenReturn(2);\nassertEquals(\nmocked overridden value\n, 2, mockedComponent.getValue());\n\n\n\n\nCustom mocking\n\n\nIt's possible to implement your own mocking behavior.\n\n\nAll you need to do is implement your own \nComponentFactory\n and implement the required methods:\n\n\npublic class CustomMockingComponentFactory implements ComponentFactory {\n\n    @Override\n    public Object create(Class\n?\n classObject, Object parent) {\n        return CustomMockingFramework.mock(classObject);\n    }\n}\n\n\n\n\nAll that is left is registering it:\n\n\nComponentInstanceManager.setComponentFactory(customComponentFactory);", 
            "title": "Testing"
        }, 
        {
            "location": "/java/testing/#testing", 
            "text": "Spork provides basic support for unit-testing. Specifically for creating mock/stub classes for components.", 
            "title": "Testing"
        }, 
        {
            "location": "/java/testing/#standard-mocking", 
            "text": "The default implementation for mocks/stubs with Spork is by injecting alternative classes into objects:  // Create a ComponentFactory for mocking\nMockingComponentFactory mockingFactory = new MockingComponentFactory()\n    .register(RegularImplementationA.class, MockedImplementationA.class)\n    .register(RegularImplementationB.class, MockedImplementationB.class);\n\n// Assign the new ComponentFactory\nComponentInstanceManager.setComponentFactory(mockingFactory);  That's it! Instead of injecting  RegularImplementation*  classes,  MockedImplementation*  classes will be instantiated and injected instead!", 
            "title": "Standard mocking"
        }, 
        {
            "location": "/java/testing/#mockito-support", 
            "text": "", 
            "title": "Mockito support"
        }, 
        {
            "location": "/java/testing/#configuration", 
            "text": "To enable Mockito support, add the following dependency:  dependencies {\n    compile ('io.github.sporklibrary:spork-mockito:1.1.0') {\n        exclude group: 'io.github.sporklibrary'\n    }\n}", 
            "title": "Configuration"
        }, 
        {
            "location": "/java/testing/#example", 
            "text": "Consider the following classes:  public class Component {\n\n    public int getValue() {\n        return 1;\n    }\n}\n\npublic class Parent {\n\n    @BindComponent\n    private Component component;\n\n    public Parent() {\n        Spork.bind(this);\n    }\n\n    public Component getComponent() {\n        return component;\n    }\n}  To start mocking, this needs to be done:  // Enable mocking for the specified class(es)\nSporkMockito.initialize(Component.class);\n// This can be called multiple times to reset the mocking classes.\n// Alternatively, mocking can be enabled for all component classes with:\n// SporkMockito.initialize()\n\n// Object instantiation\nParent parent = new Parent();\nComponent mockedComponent = parent.getComponent();\n\n// Run Mockito tests\nassertEquals( mocked default value , 0, mockedComponent.getValue());\nwhen(mockedComponent.getValue()).thenReturn(2);\nassertEquals( mocked overridden value , 2, mockedComponent.getValue());", 
            "title": "Example"
        }, 
        {
            "location": "/java/testing/#custom-mocking", 
            "text": "It's possible to implement your own mocking behavior.  All you need to do is implement your own  ComponentFactory  and implement the required methods:  public class CustomMockingComponentFactory implements ComponentFactory {\n\n    @Override\n    public Object create(Class ?  classObject, Object parent) {\n        return CustomMockingFramework.mock(classObject);\n    }\n}  All that is left is registering it:  ComponentInstanceManager.setComponentFactory(customComponentFactory);", 
            "title": "Custom mocking"
        }, 
        {
            "location": "/java/advanced/creating-annotations/", 
            "text": "Creating Annotations\n\n\nOverview\n\n\nSpork annotations are bound through a \nMethodBinder\n and/or \nFieldBinder\n and/or \nTypeBinder\n.\n\n\nThese binders are registered through a \nBinderManager\n which is accessible through \nSpork.getBinderManager()\n\n\nFieldBinder\n\n\nFieldBinders are used for annotations that target \nElementType.FIELD\n.\n\n\nExample\n\n\npublic class BindViewBinder implements FieldBinder\nBindView\n {\n\n    @Override\n    public Class\nBindView\n getAnnotationClass() {\n        return BindView.class;\n    }\n\n    @Override\n    public void bind(final Object object, final AnnotatedField\nBindView\n annotatedField) {\n        // Internally retrieves a `View` from the `object`\n        // by checking its type (Activity/Fragment/View)\n        final @Nullable View view = resolveView(object, annotatedField);\n\n        if (view == null) {\n            throw new BindException(...);\n        }\n\n        // Set the value for the object given the AnnotatedField\n        AnnotatedFields.set(annotatedField, object, view);\n    }\n}\n\n\n\n\nCheck out the \n@BindView\n annotation binder: \nBindViewBinder\n \nhere\n.\n\n\nMethodBinder\n\n\nMethodBinders are used for annotations that target \nElementType.METHOD\n.\n\n\nExample\n\n\npublic class BindClickBinder implements MethodBinder\nBindClick\n {\n\n    @Override\n    public Class\nBindClick\n getAnnotationClass() {\n        return BindClick.class;\n    }\n\n    @Override\n    public void bind(final Object object, AnnotatedMethod\nBindClick\n annotatedMethod) {\n        // Internally retrieves a 'View' from the `object`\n        // by checking its type (Activity/Fragment/View)\n        final @Nullable View view = getView(object, annotatedMethod);\n\n        if (view == null) {\n            throw new BindException(...);\n        }\n\n        // Bind the custom OnClickListener that applies Java reflection\n        // This saves CPU-intensive reflection calls until when it's necessary\n        view.setOnClickListener(new CustomListener(annotatedMethod, object));\n    }\n}\n\n\n\n\nCheck out the \n@BindClick\n annotation binder: \nBindClickBinder\n \nhere\n.\n\n\nTypeBinder\n\n\nTypeBinders are used for annotations that target \nElementType.TYPE\n.\n\n\nExample\n\n\npublic interface IntSettable {\n    void setValue(int value);\n}\n\npublic class ValueBinder implements TypeBinder\nBindValue\n {\n\n    @Override\n    public Class\nBindValue\n getAnnotationClass() {\n        return BindValue.class;\n    }\n\n    @Override\n    public void bind(Object object, AnnotatedType\nBindValue\n annotatedClass) {\n        // @BindValue only works with IntSettable implementations\n        if (!IntSettable.class.isAssignableFrom(object.getClass())) {\n            throw new BindException(...);\n        }\n\n        // Safely convert to IntSettable\n        IntSettable value_holder = (IntSettable)object;\n\n        // Set the integer value\n        int value = annotatedClass.getAnnotation().value();\n        value_holder.setValue(value);\n    }\n}\n\n\n\n\n\nCheck out the \n@BindLayout\n annotation binder: \nBindLayoutBinder\n \nhere\n.\n\n\nBinder registration\n\n\nSingle target binders\n\n\nFor binders that only bind to a single annotation target (e.g. \nElementType.FIELD\n, \nElementType.METHOD\n or \nElementType.TYPE\n). The following code demonstrates this.\n\n\nYourAnnotation.java\n\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface YourAnnotation {\n}\n\n\n\n\nYourAnnotationBinder.java\n\n\nclass YourAnnotationBinder implements MethodBinder\nYourAnnotation\n {\n    // implementation\n}\n\n\n\n\nMain.java\n\n\nSpork.getBinderManager().register(new YourAnnotationBinder());\n\n\n\n\nMulti-target binders\n\n\nFor binders that only bind to multiple annotation targets (e.g. \nElementType.FIELD\n, \nElementType.METHOD\n or \nElementType.TYPE\n). The following code demonstrates this.\n\n\nYourAnnotation.java\n\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD, Element.FIELD })\npublic @interface YourAnnotation {\n}\n\n\n\n\nYourAnnotationBinder.java\n\n\nclass YourAnnotationBinder\n    implements MethodBinder\nYourAnnotation\n, FieldBinder\nYourAnnotation\n {\n    // implementation\n}\n\n\n\n\nMain.java\n\n\nYourAnnotationBinder binder = new YourAnnotationBinder();\n\n// register as MethodBinder\nSpork.getBinderManager().register((MethodBinder\nYourAnnotation\n)binder);\n// register as FieldBinder\nSpork.getBinderManager().register((FieldBinder\nYourAnnotation\n)binder);", 
            "title": "Creating Annotations"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#creating-annotations", 
            "text": "", 
            "title": "Creating Annotations"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#overview", 
            "text": "Spork annotations are bound through a  MethodBinder  and/or  FieldBinder  and/or  TypeBinder .  These binders are registered through a  BinderManager  which is accessible through  Spork.getBinderManager()", 
            "title": "Overview"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#fieldbinder", 
            "text": "FieldBinders are used for annotations that target  ElementType.FIELD .", 
            "title": "FieldBinder"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#example", 
            "text": "public class BindViewBinder implements FieldBinder BindView  {\n\n    @Override\n    public Class BindView  getAnnotationClass() {\n        return BindView.class;\n    }\n\n    @Override\n    public void bind(final Object object, final AnnotatedField BindView  annotatedField) {\n        // Internally retrieves a `View` from the `object`\n        // by checking its type (Activity/Fragment/View)\n        final @Nullable View view = resolveView(object, annotatedField);\n\n        if (view == null) {\n            throw new BindException(...);\n        }\n\n        // Set the value for the object given the AnnotatedField\n        AnnotatedFields.set(annotatedField, object, view);\n    }\n}  Check out the  @BindView  annotation binder:  BindViewBinder   here .", 
            "title": "Example"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#methodbinder", 
            "text": "MethodBinders are used for annotations that target  ElementType.METHOD .", 
            "title": "MethodBinder"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#example_1", 
            "text": "public class BindClickBinder implements MethodBinder BindClick  {\n\n    @Override\n    public Class BindClick  getAnnotationClass() {\n        return BindClick.class;\n    }\n\n    @Override\n    public void bind(final Object object, AnnotatedMethod BindClick  annotatedMethod) {\n        // Internally retrieves a 'View' from the `object`\n        // by checking its type (Activity/Fragment/View)\n        final @Nullable View view = getView(object, annotatedMethod);\n\n        if (view == null) {\n            throw new BindException(...);\n        }\n\n        // Bind the custom OnClickListener that applies Java reflection\n        // This saves CPU-intensive reflection calls until when it's necessary\n        view.setOnClickListener(new CustomListener(annotatedMethod, object));\n    }\n}  Check out the  @BindClick  annotation binder:  BindClickBinder   here .", 
            "title": "Example"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#typebinder", 
            "text": "TypeBinders are used for annotations that target  ElementType.TYPE .", 
            "title": "TypeBinder"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#example_2", 
            "text": "public interface IntSettable {\n    void setValue(int value);\n}\n\npublic class ValueBinder implements TypeBinder BindValue  {\n\n    @Override\n    public Class BindValue  getAnnotationClass() {\n        return BindValue.class;\n    }\n\n    @Override\n    public void bind(Object object, AnnotatedType BindValue  annotatedClass) {\n        // @BindValue only works with IntSettable implementations\n        if (!IntSettable.class.isAssignableFrom(object.getClass())) {\n            throw new BindException(...);\n        }\n\n        // Safely convert to IntSettable\n        IntSettable value_holder = (IntSettable)object;\n\n        // Set the integer value\n        int value = annotatedClass.getAnnotation().value();\n        value_holder.setValue(value);\n    }\n}  Check out the  @BindLayout  annotation binder:  BindLayoutBinder   here .", 
            "title": "Example"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#binder-registration", 
            "text": "", 
            "title": "Binder registration"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#single-target-binders", 
            "text": "For binders that only bind to a single annotation target (e.g.  ElementType.FIELD ,  ElementType.METHOD  or  ElementType.TYPE ). The following code demonstrates this.  YourAnnotation.java  @Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface YourAnnotation {\n}  YourAnnotationBinder.java  class YourAnnotationBinder implements MethodBinder YourAnnotation  {\n    // implementation\n}  Main.java  Spork.getBinderManager().register(new YourAnnotationBinder());", 
            "title": "Single target binders"
        }, 
        {
            "location": "/java/advanced/creating-annotations/#multi-target-binders", 
            "text": "For binders that only bind to multiple annotation targets (e.g.  ElementType.FIELD ,  ElementType.METHOD  or  ElementType.TYPE ). The following code demonstrates this.  YourAnnotation.java  @Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD, Element.FIELD })\npublic @interface YourAnnotation {\n}  YourAnnotationBinder.java  class YourAnnotationBinder\n    implements MethodBinder YourAnnotation , FieldBinder YourAnnotation  {\n    // implementation\n}  Main.java  YourAnnotationBinder binder = new YourAnnotationBinder();\n\n// register as MethodBinder\nSpork.getBinderManager().register((MethodBinder YourAnnotation )binder);\n// register as FieldBinder\nSpork.getBinderManager().register((FieldBinder YourAnnotation )binder);", 
            "title": "Multi-target binders"
        }, 
        {
            "location": "/java/advanced/proguard/", 
            "text": "ProGuard\n\n\nProGuard's shrinking process might remove your components, because they are instantiated by reflection instead of the regular way. To avoid this, you need to specify the classes and interfaces to keep in your proguard configuration.\n\n\nExample\n\n\n-keep class com.yourapp.components.** { *; }\n-keep interface com.yourapp.components.** { *; }", 
            "title": "ProGuard"
        }, 
        {
            "location": "/java/advanced/proguard/#proguard", 
            "text": "ProGuard's shrinking process might remove your components, because they are instantiated by reflection instead of the regular way. To avoid this, you need to specify the classes and interfaces to keep in your proguard configuration.", 
            "title": "ProGuard"
        }, 
        {
            "location": "/java/advanced/proguard/#example", 
            "text": "-keep class com.yourapp.components.** { *; }\n-keep interface com.yourapp.components.** { *; }", 
            "title": "Example"
        }, 
        {
            "location": "/java/advanced/binding-order/", 
            "text": "Binding Order\n\n\nComponents are bound by the order they are registered in. This means that components are bound first and any other registered annotations are bound after that.\n\n\nComponents\n\n\nWhen \nSpork.bind()\n is called, the \n@BindComponent\n annotations are processed first. This means that when the component is bound, the \n@ComponentParent\n passed in the constructor can be acccessed, but the injection on \n@ComponentParent\n fields might not have finished.\n\n\nExample\n\n\npublic class ExampleActivity extends Activity {\n\n    @BindComponent\n    private Component component;\n\n    @BindView(R.id.test)\n    private View testView;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Spork.bind(this);\n    }\n\n    public View getTestView() {\n        return testView;\n    }\n}\n\npublic class Component {\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        // at this point, activity.getView() will still return null\n    }\n}\n\n\n\n\nSolution 1\n\n\nStore the component parent and access its properties only by reference.\n\n\npublic class ExampleActivity extends Activity {\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void show() {\n        // as long as show() is called after the parent's\n        // Spork.bind() then all is fine\n        activity.getView().setVisibility(View.VISIBLE);\n    }\n}\n\n\n\n\nSolution 2\n\n\nCache the fields when any of the component methods are called.\n\n\npublic class ExampleActivity extends Activity {\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n    private View view;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void show() {\n        assureViewsCached();\n        view.setVisibility(View.VISIBLE);\n    }\n\n    private void assureViewsCached() {\n        if (view == null) {\n            view = activity.getView();\n        }\n    }\n}\n\n\n\n\nSolution 3\n\n\nGive your component an initializing method and call it after the parent's \nSpork.bind()\n\n\npublic class ExampleActivity extends Activity {\n    // ...\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Spork.bind(this);\n\n        component.initialize(); // initialization after binding finished\n    }\n\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n    private View view;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void initialize() {\n        // Cache view\n        view = activity.getView();\n    }\n}\n\n\n\n\nInheritance\n\n\nWhen extending classes, you should only call \nSpork.bind()\n in the base class where you want to apply bindings. All derived classes will automatically get bound too.\n\n\nInjection for classes that apply inheritance happens from the most top-level class to the bottom level base class.\n\n\nclass ComponentBase {\n    public ComponentBase() {\n        Spork.bind(this);\n    }\n}\n\nclass Component extends ComponentBase {\n    @BindComponent\n    private SomeOtherComponent someOtherComponent;\n\n    // No need to call Spork.bind() because superclass handles that\n}\n\nclass Parent {\n    @BindComponent\n    private Component component;\n\n    public Parent() {\n        // Component is injected and both Component and ComponentBase\n        // annotations are processed\n        Spork.bind(this);\n    }\n}", 
            "title": "Binding order"
        }, 
        {
            "location": "/java/advanced/binding-order/#binding-order", 
            "text": "Components are bound by the order they are registered in. This means that components are bound first and any other registered annotations are bound after that.", 
            "title": "Binding Order"
        }, 
        {
            "location": "/java/advanced/binding-order/#components", 
            "text": "When  Spork.bind()  is called, the  @BindComponent  annotations are processed first. This means that when the component is bound, the  @ComponentParent  passed in the constructor can be acccessed, but the injection on  @ComponentParent  fields might not have finished.", 
            "title": "Components"
        }, 
        {
            "location": "/java/advanced/binding-order/#example", 
            "text": "public class ExampleActivity extends Activity {\n\n    @BindComponent\n    private Component component;\n\n    @BindView(R.id.test)\n    private View testView;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Spork.bind(this);\n    }\n\n    public View getTestView() {\n        return testView;\n    }\n}\n\npublic class Component {\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        // at this point, activity.getView() will still return null\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/java/advanced/binding-order/#solution-1", 
            "text": "Store the component parent and access its properties only by reference.  public class ExampleActivity extends Activity {\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void show() {\n        // as long as show() is called after the parent's\n        // Spork.bind() then all is fine\n        activity.getView().setVisibility(View.VISIBLE);\n    }\n}", 
            "title": "Solution 1"
        }, 
        {
            "location": "/java/advanced/binding-order/#solution-2", 
            "text": "Cache the fields when any of the component methods are called.  public class ExampleActivity extends Activity {\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n    private View view;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void show() {\n        assureViewsCached();\n        view.setVisibility(View.VISIBLE);\n    }\n\n    private void assureViewsCached() {\n        if (view == null) {\n            view = activity.getView();\n        }\n    }\n}", 
            "title": "Solution 2"
        }, 
        {
            "location": "/java/advanced/binding-order/#solution-3", 
            "text": "Give your component an initializing method and call it after the parent's  Spork.bind()  public class ExampleActivity extends Activity {\n    // ...\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Spork.bind(this);\n\n        component.initialize(); // initialization after binding finished\n    }\n\n    // ...\n}\n\npublic class Component {\n    private final ExampleActivity activity;\n    private View view;\n\n    public Component(@ComponentParent ExampleActivity activity) {\n        this.activity = activity;\n    }\n\n    public void initialize() {\n        // Cache view\n        view = activity.getView();\n    }\n}", 
            "title": "Solution 3"
        }, 
        {
            "location": "/java/advanced/binding-order/#inheritance", 
            "text": "When extending classes, you should only call  Spork.bind()  in the base class where you want to apply bindings. All derived classes will automatically get bound too.  Injection for classes that apply inheritance happens from the most top-level class to the bottom level base class.  class ComponentBase {\n    public ComponentBase() {\n        Spork.bind(this);\n    }\n}\n\nclass Component extends ComponentBase {\n    @BindComponent\n    private SomeOtherComponent someOtherComponent;\n\n    // No need to call Spork.bind() because superclass handles that\n}\n\nclass Parent {\n    @BindComponent\n    private Component component;\n\n    public Parent() {\n        // Component is injected and both Component and ComponentBase\n        // annotations are processed\n        Spork.bind(this);\n    }\n}", 
            "title": "Inheritance"
        }
    ]
}