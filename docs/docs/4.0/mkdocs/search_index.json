{
    "docs": [
        {
            "location": "/", 
            "text": "Spork 4.0\n\n\nGetting started on Android\n\n\nWARNING\n: Spork 4.0 is only accessible as a snapshot release.\nThis is not a final release and is subject to potential changes in its API.\n\n\nAdd the following dependencies in \nbuild.gradle\n:\n\n\nrepositories {\n    maven {\n        url  \nhttp://dl.bintray.com/bytewelder/maven-snapshot\n \n    }\n}\n\ndependencies {\n    // Spork core\n    compile 'com.bytewelder.spork:spork:4.0.0'\n\n    // Spork Dependency Injection\n    compile 'com.bytewelder.spork:spork-inject:4.0.0'\n\n    // Spork for Android (second line is optional)\n    compile 'com.bytewelder.spork:spork-android:4.0.0@aar'\n    compile 'com.bytewelder.spork:spork-android-support:4.0.0@aar'\n}\n\n\n\n\nGetting started on Java\n\n\nAdd the following dependencies in \nbuild.gradle\n:\n\n\ndependencies {\n    compile 'com.bytewelder.spork:spork:4.0.0'\n    compile 'com.bytewelder.spork:spork-inject:4.0.0'\n}\n\n\n\n\nAll dependencies are available at \nMaven Central Repository\n.\n\n\nMigrating from 3.x to 4.0:\n\n\n\n\nrepository is moved to jCenter with snapshots at http://dl.bintray.com/bytewelder/maven-snapshot\n\n\nbase packages moved from \nio.github.sporklibrary\n to \nspork\n\n\n@BindComponent\n is now \n@Inject\n (with support for \n@Nullable\n, \n@NonNull\n and \n@Lazy\n annotations)\n\n\n@ComponentScope(Scope.SINGLETON)\n is now \n@Singleton\n\n\nremoved custom support for \nRecyclerView.ViewHolder\n as you can now make it implement \nViewProvider\n\n\nFieldBinder\n, \nMethodBinder\n and \nTypeBinder\n interfaces are changed", 
            "title": "Home"
        }, 
        {
            "location": "/#spork-40", 
            "text": "", 
            "title": "Spork 4.0"
        }, 
        {
            "location": "/#getting-started-on-android", 
            "text": "WARNING : Spork 4.0 is only accessible as a snapshot release. This is not a final release and is subject to potential changes in its API.  Add the following dependencies in  build.gradle :  repositories {\n    maven {\n        url   http://dl.bintray.com/bytewelder/maven-snapshot  \n    }\n}\n\ndependencies {\n    // Spork core\n    compile 'com.bytewelder.spork:spork:4.0.0'\n\n    // Spork Dependency Injection\n    compile 'com.bytewelder.spork:spork-inject:4.0.0'\n\n    // Spork for Android (second line is optional)\n    compile 'com.bytewelder.spork:spork-android:4.0.0@aar'\n    compile 'com.bytewelder.spork:spork-android-support:4.0.0@aar'\n}", 
            "title": "Getting started on Android"
        }, 
        {
            "location": "/#getting-started-on-java", 
            "text": "Add the following dependencies in  build.gradle :  dependencies {\n    compile 'com.bytewelder.spork:spork:4.0.0'\n    compile 'com.bytewelder.spork:spork-inject:4.0.0'\n}  All dependencies are available at  Maven Central Repository .", 
            "title": "Getting started on Java"
        }, 
        {
            "location": "/#migrating-from-3x-to-40", 
            "text": "repository is moved to jCenter with snapshots at http://dl.bintray.com/bytewelder/maven-snapshot  base packages moved from  io.github.sporklibrary  to  spork  @BindComponent  is now  @Inject  (with support for  @Nullable ,  @NonNull  and  @Lazy  annotations)  @ComponentScope(Scope.SINGLETON)  is now  @Singleton  removed custom support for  RecyclerView.ViewHolder  as you can now make it implement  ViewProvider  FieldBinder ,  MethodBinder  and  TypeBinder  interfaces are changed", 
            "title": "Migrating from 3.x to 4.0:"
        }, 
        {
            "location": "/spork-core/introduction/", 
            "text": "Spork Core\n\n\nSpork Core contains the basic building blocks where the other Spork libraries are built upon.\n\n\nIt is provides annotation processing interfaces for classes(\"types\"), fields and methods.\n\n\nDependencies\n\n\nAdd the following dependencies in \nbuild.gradle\n:\n\n\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    compile 'com.bytewelder.spork:spork:4.0.0'\n}", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-core/introduction/#spork-core", 
            "text": "Spork Core contains the basic building blocks where the other Spork libraries are built upon.  It is provides annotation processing interfaces for classes(\"types\"), fields and methods.", 
            "title": "Spork Core"
        }, 
        {
            "location": "/spork-core/introduction/#dependencies", 
            "text": "Add the following dependencies in  build.gradle :  repositories {\n    jcenter()\n}\n\ndependencies {\n    compile 'com.bytewelder.spork:spork:4.0.0'\n}", 
            "title": "Dependencies"
        }, 
        {
            "location": "/spork-core/creating-annotations/", 
            "text": "Creating Annotations\n\n\nOverview\n\n\nSpork annotations are bound through one or more of:\n\n\n\n\nMethodBinder\n\n\nFieldBinder\n\n\nTypeBinder\n\n\n\n\nThese binders are registered through a \nBinderRegistery\n which is accessible through \nSpork.sharedInstance().getBinderRegistry()\n\n\nFieldBinder\n\n\nFieldBinders are used for annotations that target \nElementType.FIELD\n.\n\n\nExample\n\n\npublic class BindViewBinder implements FieldBinder\nBindView\n {\n\n    @Override\n    public void bind(Object object, BindView annotation, Field field, Object[] modules) {\n        if (!View.class.isAssignableFrom(field.getType())) {\n            throw new BindException(/* ... */);\n        }\n\n        View view = Views.getView(viewResolver, annotation.value(), field.getName(), object);\n\n        Reflection.setFieldValue(annotation, field, object, view);\n    }\n\n    @Override\n    public Class\nBindView\n getAnnotationClass() {\n        return BindView.class;\n    }\n}\n\n\n\n\nMethodBinder\n\n\nMethodBinders are used for annotations that target \nElementType.METHOD\n.\n\n\nExample\n\n\npublic class BindClickBinder implements MethodBinder\nBindClick\n {\n\n    @Override\n    public void bind(Object object, BindClick annotation, Method method, @Nullable Object[] modules) {\n        View view = Views.getView(viewResolver, annotation.value(), method.getName(), object);\n        view.setOnClickListener(new OnClickListener() {\n            /* handle click */\n        });\n    }\n\n    @Override\n    public Class\nBindClick\n getAnnotationClass() {\n        return BindClick.class;\n    }\n}\n\n\n\n\nTypeBinder\n\n\nTypeBinders are used for annotations that target \nElementType.TYPE\n.\n\n\nExample\n\n\npublic interface IntSettable {\n    void setValue(int value);\n}\n\npublic class ValueBinder implements TypeBinder\nBindValue\n {\n\n    @Override\n    void bind(Object object, IntSettable annotation, Class\n?\n annotatedType, Object[] modules) {\n        // @BindValue only works with IntSettable implementations\n        if (!IntSettable.class.isAssignableFrom(object.getClass())) {\n            throw new BindException(/* ... */);\n        }\n\n        // Safely convert to IntSettable\n        IntSettable value_holder = (IntSettable)object;\n\n        // Set the integer value\n        int value = annotatedClass.getAnnotation().value();\n        value_holder.setValue(value);\n    }\n\n    @Override\n    public Class\nBindValue\n getAnnotationClass() {\n        return BindValue.class;\n    }\n}\n\n\n\n\n\nBinder registration\n\n\nSingle target binders\n\n\nFor binders that only bind to a single annotation target (e.g. \nElementType.FIELD\n, \nElementType.METHOD\n or \nElementType.TYPE\n). The following code demonstrates this.\n\n\nYourAnnotation.java\n\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface YourAnnotation {\n}\n\n\n\n\nYourAnnotationBinder.java\n\n\nclass YourAnnotationBinder implements MethodBinder\nYourAnnotation\n {\n    // implementation\n}\n\n\n\n\nMain.java\n\n\nSpork.sharedInstance().getBinderRegistry().register(new YourAnnotationBinder());\n\n\n\n\nMulti-target binders\n\n\nFor binders that only bind to multiple annotation targets (e.g. \nElementType.FIELD\n, \nElementType.METHOD\n or \nElementType.TYPE\n). The following code demonstrates this.\n\n\nYourAnnotation.java\n\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD, Element.FIELD })\npublic @interface YourAnnotation {\n}\n\n\n\n\nYourAnnotationBinder.java\n\n\nclass YourAnnotationBinder\n    implements MethodBinder\nYourAnnotation\n, FieldBinder\nYourAnnotation\n {\n    // implementation\n}\n\n\n\n\nMain.java\n\n\nYourAnnotationBinder binder = new YourAnnotationBinder();\n\n// register as MethodBinder\nSpork.sharedInstance().getBinderRegistry().register((MethodBinder\nYourAnnotation\n)binder);\n// register as FieldBinder\nSpork.sharedInstance().getBinderRegistry().register((FieldBinder\nYourAnnotation\n)binder);", 
            "title": "Creating Annotations"
        }, 
        {
            "location": "/spork-core/creating-annotations/#creating-annotations", 
            "text": "", 
            "title": "Creating Annotations"
        }, 
        {
            "location": "/spork-core/creating-annotations/#overview", 
            "text": "Spork annotations are bound through one or more of:   MethodBinder  FieldBinder  TypeBinder   These binders are registered through a  BinderRegistery  which is accessible through  Spork.sharedInstance().getBinderRegistry()", 
            "title": "Overview"
        }, 
        {
            "location": "/spork-core/creating-annotations/#fieldbinder", 
            "text": "FieldBinders are used for annotations that target  ElementType.FIELD .", 
            "title": "FieldBinder"
        }, 
        {
            "location": "/spork-core/creating-annotations/#example", 
            "text": "public class BindViewBinder implements FieldBinder BindView  {\n\n    @Override\n    public void bind(Object object, BindView annotation, Field field, Object[] modules) {\n        if (!View.class.isAssignableFrom(field.getType())) {\n            throw new BindException(/* ... */);\n        }\n\n        View view = Views.getView(viewResolver, annotation.value(), field.getName(), object);\n\n        Reflection.setFieldValue(annotation, field, object, view);\n    }\n\n    @Override\n    public Class BindView  getAnnotationClass() {\n        return BindView.class;\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-core/creating-annotations/#methodbinder", 
            "text": "MethodBinders are used for annotations that target  ElementType.METHOD .", 
            "title": "MethodBinder"
        }, 
        {
            "location": "/spork-core/creating-annotations/#example_1", 
            "text": "public class BindClickBinder implements MethodBinder BindClick  {\n\n    @Override\n    public void bind(Object object, BindClick annotation, Method method, @Nullable Object[] modules) {\n        View view = Views.getView(viewResolver, annotation.value(), method.getName(), object);\n        view.setOnClickListener(new OnClickListener() {\n            /* handle click */\n        });\n    }\n\n    @Override\n    public Class BindClick  getAnnotationClass() {\n        return BindClick.class;\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-core/creating-annotations/#typebinder", 
            "text": "TypeBinders are used for annotations that target  ElementType.TYPE .", 
            "title": "TypeBinder"
        }, 
        {
            "location": "/spork-core/creating-annotations/#example_2", 
            "text": "public interface IntSettable {\n    void setValue(int value);\n}\n\npublic class ValueBinder implements TypeBinder BindValue  {\n\n    @Override\n    void bind(Object object, IntSettable annotation, Class ?  annotatedType, Object[] modules) {\n        // @BindValue only works with IntSettable implementations\n        if (!IntSettable.class.isAssignableFrom(object.getClass())) {\n            throw new BindException(/* ... */);\n        }\n\n        // Safely convert to IntSettable\n        IntSettable value_holder = (IntSettable)object;\n\n        // Set the integer value\n        int value = annotatedClass.getAnnotation().value();\n        value_holder.setValue(value);\n    }\n\n    @Override\n    public Class BindValue  getAnnotationClass() {\n        return BindValue.class;\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-core/creating-annotations/#binder-registration", 
            "text": "", 
            "title": "Binder registration"
        }, 
        {
            "location": "/spork-core/creating-annotations/#single-target-binders", 
            "text": "For binders that only bind to a single annotation target (e.g.  ElementType.FIELD ,  ElementType.METHOD  or  ElementType.TYPE ). The following code demonstrates this.  YourAnnotation.java  @Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface YourAnnotation {\n}  YourAnnotationBinder.java  class YourAnnotationBinder implements MethodBinder YourAnnotation  {\n    // implementation\n}  Main.java  Spork.sharedInstance().getBinderRegistry().register(new YourAnnotationBinder());", 
            "title": "Single target binders"
        }, 
        {
            "location": "/spork-core/creating-annotations/#multi-target-binders", 
            "text": "For binders that only bind to multiple annotation targets (e.g.  ElementType.FIELD ,  ElementType.METHOD  or  ElementType.TYPE ). The following code demonstrates this.  YourAnnotation.java  @Retention(RetentionPolicy.RUNTIME)\n@Target({ ElementType.METHOD, Element.FIELD })\npublic @interface YourAnnotation {\n}  YourAnnotationBinder.java  class YourAnnotationBinder\n    implements MethodBinder YourAnnotation , FieldBinder YourAnnotation  {\n    // implementation\n}  Main.java  YourAnnotationBinder binder = new YourAnnotationBinder();\n\n// register as MethodBinder\nSpork.sharedInstance().getBinderRegistry().register((MethodBinder YourAnnotation )binder);\n// register as FieldBinder\nSpork.sharedInstance().getBinderRegistry().register((FieldBinder YourAnnotation )binder);", 
            "title": "Multi-target binders"
        }, 
        {
            "location": "/spork-inject/introduction/", 
            "text": "Spork Inject\n\n\nSpork Inject is a runtime \ndependency injection\n framework for Java and Android. It is almost fully compatible with \nDagger\n and is modeled on the \nJSR-330\n specification.\n\n\nSpork Injection aims to avoid code generation as even mobile devices have become effective to apply injection at runtime with \ngreat performance\n.\n\n\nDependencies\n\n\nAdd the following dependencies in \nbuild.gradle\n:\n\n\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    compile 'com.bytewelder.spork:spork:4.0.0'\n    compile 'com.bytewelder.spork:spork-inject:4.0.0'\n}\n\n\n\n\nExample\n\n\npublic static class Module {\n    @Provides\n    public Integer provideNumber() {\n        return 1;\n    }\n\n    @Provides\n    @Named(\ncolor\n)\n    public String provideColor() {\n        return \nred\n;\n    }\n\n    @Provides\n    @Named(\nlabel\n)\n    public String provideLabel() {\n        return \nHi!\n;\n    }\n\n    @Provides\n    @Singleton\n    public RestService provideRestService(HttpService service) {\n        return new RestServiceImpl(service);\n    }\n\n    @Provides\n    @Singleton\n    public HttpService provideHttpService() {\n        return new HttpServiceImpl(service);\n    }\n}\n\nprivate static class Parent {\n    @Inject\n    private Integer number;\n\n    @Inject\n    @Named(\ncolor\n)\n    private String color;\n\n    @Inject\n    @Named(\nlabel\n)\n    private String label;\n\n    @Inject\n    private RestService restService;\n\n    public Parent() {\n        ObjectGraph graph = new ObjectGraph.Builder()\n                .module(new Module())\n                .build();\n\n        Spork.bind(this, graph);\n    }\n}", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-inject/introduction/#spork-inject", 
            "text": "Spork Inject is a runtime  dependency injection  framework for Java and Android. It is almost fully compatible with  Dagger  and is modeled on the  JSR-330  specification.  Spork Injection aims to avoid code generation as even mobile devices have become effective to apply injection at runtime with  great performance .", 
            "title": "Spork Inject"
        }, 
        {
            "location": "/spork-inject/introduction/#dependencies", 
            "text": "Add the following dependencies in  build.gradle :  repositories {\n    jcenter()\n}\n\ndependencies {\n    compile 'com.bytewelder.spork:spork:4.0.0'\n    compile 'com.bytewelder.spork:spork-inject:4.0.0'\n}", 
            "title": "Dependencies"
        }, 
        {
            "location": "/spork-inject/introduction/#example", 
            "text": "public static class Module {\n    @Provides\n    public Integer provideNumber() {\n        return 1;\n    }\n\n    @Provides\n    @Named( color )\n    public String provideColor() {\n        return  red ;\n    }\n\n    @Provides\n    @Named( label )\n    public String provideLabel() {\n        return  Hi! ;\n    }\n\n    @Provides\n    @Singleton\n    public RestService provideRestService(HttpService service) {\n        return new RestServiceImpl(service);\n    }\n\n    @Provides\n    @Singleton\n    public HttpService provideHttpService() {\n        return new HttpServiceImpl(service);\n    }\n}\n\nprivate static class Parent {\n    @Inject\n    private Integer number;\n\n    @Inject\n    @Named( color )\n    private String color;\n\n    @Inject\n    @Named( label )\n    private String label;\n\n    @Inject\n    private RestService restService;\n\n    public Parent() {\n        ObjectGraph graph = new ObjectGraph.Builder()\n                .module(new Module())\n                .build();\n\n        Spork.bind(this, graph);\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-inject/user-guide/", 
            "text": "User Guide\n\n\nUsing Spork Inject\n\n\nSpork creates instances of your classes and satisfies their dependencies. It uses the \njavax.inject.Inject\n annotation to identify which constructors and fields it is interested in.\n\n\nUse \nSpork.bind()\n in constructor or initialization methods so Spork can create instances of the dependencies. When a new instance is requested, Spork will obtain the required parameters values and invoke its constructor.\n\n\nclass Car implements Vehicle {\n    private final Engine engine;\n    private final Driver driver;\n\n    @Inject\n    Car(Engine engine, Driver driver) {\n        this.engine = engine;\n        this.driver = driver;\n    }\n}\n\n\n\n\nSpork can inject fields directly. In this example it obtains an \nEngine\n instance for the \nengine\n field and a \nDriver\n instance for the \ndriver\n field.\n\n\nclass Car {\n    @Inject private Engine engine;\n    @Inject private Driver driver;\n\n    public Car() {\n        Spork.bind(...);\n    }\n}\n\n\n\n\nSpork also supports method injection, but Field injection is generally preferred.\n\n\nClasses that lack \n@Inject\n annotations cannot be constructed by Spork.\n\n\nDeclaring Dependencies\n\n\nIn the above sample, an \nEngine\n and \nDriver\n are injected. Of course these dependencies must come from somewhere.\n\n\nDependencies should be defined in a Module like this:\n\n\n@Provides Engine provideEngine() {\n  return new DieselEngine();\n}\n\n\n\n\nIt's possible for a \n@Provides\n method to require dependencies on its own:\n\n\n@Provides Engine provideEngine(Piston piston) {\n  return new DieselEngine(piston);\n}\n\n@Provides Piston providePiston() {\n  return new StrongPiston();\n}\n\n\n\n\nModules\n\n\nThe \n@Provides\n-annotated methods above are placed in a \nModule\n. Modules are POJO objects that define a set of dependencies:\n\n\nclass CarModule {\n    @Provides Engine provideEngine(Piston piston) {\n      return new DieselEngine(piston);\n    }\n\n    @Provides Piston providePiston() {\n      return new StrongPiston();\n    }\n}\n\n\n\n\nBuilding an ObjectGraph\n\n\nA module is used to build an object graph. Object graphs hold state such as your singletons and named instances.\n\n\nCreating an \nObjectGraph\n is easy:\n\n\nObjectGraph objectGraph = new ObjectGraph.Builder()\n    .module(new CarModule())\n    .build();\n\n\n\n\nAn \nObjectGraph\n is then used to inject an instance:\n\n\nclass Car {\n    @Inject Engine engine;\n    @Inject Driver driver;\n\n    public Car() {\n        Spork.bind(this, objectGraph);\n    }\n}\n\n\n\n\nObject graphs can be nested. An object graph can have a parent object graph:\n\n\nObjectGraph objectGraph = new ObjectGraph.Builder(applicationObjectGraph)\n    .module(new CarModule())\n    .build();\n\n\n\n\nThis way, it can resolve dependencies from its parent \nand\n from the \nCarModule\n.\n\n\nSingletons and Scoped bindings\n\n\nModule methods annotated with \n@Provides\n can also have scope annotations. Scopes can be custom-made, but \n@Singleton\n is one that is available by default. It can be used like this:\n\n\n@Provides\n@Singleton\nUserService provideUserService() {\n    return new UserServiceImpl();\n}\n\n\n\n\nScoped instances such as the singleton instance above are associated with the \nObjectGraph\n that the \nModule\n belons to. This means that their scope is only valid for objects injected with that \nObjectGraph\n.\n\n\nLazy injection\n\n\nInstead of injecting an instance directly, they can also injected on a \nLazy\nT\n field. When \nget()\n is called on the \nLazy\n field, it will retrieve the injected instance from the module. Calling \nget()\n multiple times will return the same instances every time.\n\n\nclass Car {\n    @Inject private Lazy\nEngine\n engine;\n\n    public Car() {\n        Spork.bind(...);\n\n        engine.get().start();\n    }\n}\n\n\n\n\nProvider injection\n\n\nA \nProvider\nT\n is similar to a \nLazy\nT\n field, but injects a new instance every time it is called.\n\n\nInjecting \nProvider\nT\n is generally not advised. You might want to use the factory pattern instead or re-organize your logic and use a \nLazy\nT\n field instead.\n\n\nclass Car {\n    @Inject private Provider\nEngine\n engine;\n\n    public Car() {\n        Spork.bind(...);\n\n        engine.get().start();\n    }\n}\n\n\n\n\nQualifiers\n\n\nSometimes it is not sufficient to bind by type alone. In such cases, you might want to identify an injection by some kind of identifier.\n\n\nIn such cases, you can define a new annotation and add to it a \n@Qualifier\n annotation.\n\n\nNamed\n\n\nThe \n@Named\n annotation is one that is available by default:\n\n\n@Qualifier\n@Documented\n@Retention(RUNTIME)\npublic @interface Named {\n    String value() default \n;\n}\n\n\n\n\nA module is then available to provide named injections:\n\n\nclass CarModule {\n    @Provides\n    @Named(\ndriver\n)\n    public Seat provideDriverSeat() {\n        ...\n    }\n\n    @Provides\n    @Named(\npassenger\n)\n    public Seat providePassengerSeat() {\n        ...\n    }\n}\n\n\n\n\nThis module can then be used to inject a Car:\n\n\nclass Car {\n    @Inject\n    @Named(\ndriver\n)\n    Seat driverSeat;\n\n    @Inject\n    @Named(\npassenger\n)\n    Seat passengerSeat;\n\n    ...\n}\n\n\n\n\nCustom qualifiers\n\n\nYou can also define your own qualifiers. For example:\n\n\n@Qualifier\n@Documented\n@Retention(RUNTIME)\npublic @interface Colored {\n    Color value() default Color.WHITE;\n}\n\n\n\n\nAfter defining the annotation, we have to define how it can serialize into a unique identifier:\n\n\nAnnotationSerializers.register(Colored.class, new ColoredSerializer());\n\n\n\n\nAdding spork to your project\n\n\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    compile 'com.bytewelder.spork:spork-inject:4.0.0'\n}\n\n\n\n\nNote\n: Before release, \nspork-inject\n is available at maven repository \nhttp://dl.bintray.com/bytewelder/maven-snapshot\n\n\nLicense\n\n\nLicensed under the Apache License, Version 2.0 (the \nLicense\n);\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \nAS IS\n BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "User Guide"
        }, 
        {
            "location": "/spork-inject/user-guide/#user-guide", 
            "text": "", 
            "title": "User Guide"
        }, 
        {
            "location": "/spork-inject/user-guide/#using-spork-inject", 
            "text": "Spork creates instances of your classes and satisfies their dependencies. It uses the  javax.inject.Inject  annotation to identify which constructors and fields it is interested in.  Use  Spork.bind()  in constructor or initialization methods so Spork can create instances of the dependencies. When a new instance is requested, Spork will obtain the required parameters values and invoke its constructor.  class Car implements Vehicle {\n    private final Engine engine;\n    private final Driver driver;\n\n    @Inject\n    Car(Engine engine, Driver driver) {\n        this.engine = engine;\n        this.driver = driver;\n    }\n}  Spork can inject fields directly. In this example it obtains an  Engine  instance for the  engine  field and a  Driver  instance for the  driver  field.  class Car {\n    @Inject private Engine engine;\n    @Inject private Driver driver;\n\n    public Car() {\n        Spork.bind(...);\n    }\n}  Spork also supports method injection, but Field injection is generally preferred.  Classes that lack  @Inject  annotations cannot be constructed by Spork.", 
            "title": "Using Spork Inject"
        }, 
        {
            "location": "/spork-inject/user-guide/#declaring-dependencies", 
            "text": "In the above sample, an  Engine  and  Driver  are injected. Of course these dependencies must come from somewhere.  Dependencies should be defined in a Module like this:  @Provides Engine provideEngine() {\n  return new DieselEngine();\n}  It's possible for a  @Provides  method to require dependencies on its own:  @Provides Engine provideEngine(Piston piston) {\n  return new DieselEngine(piston);\n}\n\n@Provides Piston providePiston() {\n  return new StrongPiston();\n}", 
            "title": "Declaring Dependencies"
        }, 
        {
            "location": "/spork-inject/user-guide/#modules", 
            "text": "The  @Provides -annotated methods above are placed in a  Module . Modules are POJO objects that define a set of dependencies:  class CarModule {\n    @Provides Engine provideEngine(Piston piston) {\n      return new DieselEngine(piston);\n    }\n\n    @Provides Piston providePiston() {\n      return new StrongPiston();\n    }\n}", 
            "title": "Modules"
        }, 
        {
            "location": "/spork-inject/user-guide/#building-an-objectgraph", 
            "text": "A module is used to build an object graph. Object graphs hold state such as your singletons and named instances.  Creating an  ObjectGraph  is easy:  ObjectGraph objectGraph = new ObjectGraph.Builder()\n    .module(new CarModule())\n    .build();  An  ObjectGraph  is then used to inject an instance:  class Car {\n    @Inject Engine engine;\n    @Inject Driver driver;\n\n    public Car() {\n        Spork.bind(this, objectGraph);\n    }\n}  Object graphs can be nested. An object graph can have a parent object graph:  ObjectGraph objectGraph = new ObjectGraph.Builder(applicationObjectGraph)\n    .module(new CarModule())\n    .build();  This way, it can resolve dependencies from its parent  and  from the  CarModule .", 
            "title": "Building an ObjectGraph"
        }, 
        {
            "location": "/spork-inject/user-guide/#singletons-and-scoped-bindings", 
            "text": "Module methods annotated with  @Provides  can also have scope annotations. Scopes can be custom-made, but  @Singleton  is one that is available by default. It can be used like this:  @Provides\n@Singleton\nUserService provideUserService() {\n    return new UserServiceImpl();\n}  Scoped instances such as the singleton instance above are associated with the  ObjectGraph  that the  Module  belons to. This means that their scope is only valid for objects injected with that  ObjectGraph .", 
            "title": "Singletons and Scoped bindings"
        }, 
        {
            "location": "/spork-inject/user-guide/#lazy-injection", 
            "text": "Instead of injecting an instance directly, they can also injected on a  Lazy T  field. When  get()  is called on the  Lazy  field, it will retrieve the injected instance from the module. Calling  get()  multiple times will return the same instances every time.  class Car {\n    @Inject private Lazy Engine  engine;\n\n    public Car() {\n        Spork.bind(...);\n\n        engine.get().start();\n    }\n}", 
            "title": "Lazy injection"
        }, 
        {
            "location": "/spork-inject/user-guide/#provider-injection", 
            "text": "A  Provider T  is similar to a  Lazy T  field, but injects a new instance every time it is called.  Injecting  Provider T  is generally not advised. You might want to use the factory pattern instead or re-organize your logic and use a  Lazy T  field instead.  class Car {\n    @Inject private Provider Engine  engine;\n\n    public Car() {\n        Spork.bind(...);\n\n        engine.get().start();\n    }\n}", 
            "title": "Provider injection"
        }, 
        {
            "location": "/spork-inject/user-guide/#qualifiers", 
            "text": "Sometimes it is not sufficient to bind by type alone. In such cases, you might want to identify an injection by some kind of identifier.  In such cases, you can define a new annotation and add to it a  @Qualifier  annotation.", 
            "title": "Qualifiers"
        }, 
        {
            "location": "/spork-inject/user-guide/#named", 
            "text": "The  @Named  annotation is one that is available by default:  @Qualifier\n@Documented\n@Retention(RUNTIME)\npublic @interface Named {\n    String value() default  ;\n}  A module is then available to provide named injections:  class CarModule {\n    @Provides\n    @Named( driver )\n    public Seat provideDriverSeat() {\n        ...\n    }\n\n    @Provides\n    @Named( passenger )\n    public Seat providePassengerSeat() {\n        ...\n    }\n}  This module can then be used to inject a Car:  class Car {\n    @Inject\n    @Named( driver )\n    Seat driverSeat;\n\n    @Inject\n    @Named( passenger )\n    Seat passengerSeat;\n\n    ...\n}", 
            "title": "Named"
        }, 
        {
            "location": "/spork-inject/user-guide/#custom-qualifiers", 
            "text": "You can also define your own qualifiers. For example:  @Qualifier\n@Documented\n@Retention(RUNTIME)\npublic @interface Colored {\n    Color value() default Color.WHITE;\n}  After defining the annotation, we have to define how it can serialize into a unique identifier:  AnnotationSerializers.register(Colored.class, new ColoredSerializer());", 
            "title": "Custom qualifiers"
        }, 
        {
            "location": "/spork-inject/user-guide/#adding-spork-to-your-project", 
            "text": "repositories {\n    jcenter()\n}\n\ndependencies {\n    compile 'com.bytewelder.spork:spork-inject:4.0.0'\n}  Note : Before release,  spork-inject  is available at maven repository  http://dl.bintray.com/bytewelder/maven-snapshot", 
            "title": "Adding spork to your project"
        }, 
        {
            "location": "/spork-inject/user-guide/#license", 
            "text": "Licensed under the Apache License, Version 2.0 (the  License );\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an  AS IS  BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", 
            "title": "License"
        }, 
        {
            "location": "/spork-inject/migrating-from-dagger/", 
            "text": "Migrating from Dagger\n\n\nThese are the main differences between Dagger and Spork:\n\n\n\n\nComponents are replaced by \nObjectGraph\n and also depends on module classes\n\n\nYou need to call \nSpork.bind(this, objectGraph)\n in your object's constructor or initialization method\n\n\nProvides\n and \nLazy\n classes are in the \nspork.inject\n package\n\n\nNo need to annotate your module classes with \n@Module\n\n\nSpork is able to inject \nprivate\n fields and methods\n\n\n\n\nDagger annotations that Spork doesn't support (yet):\n\n\n\n\n@Reusable\n\n\n@ForReleasableReferences\n\n\n@BindsOptionalOf", 
            "title": "Migrating from Dagger"
        }, 
        {
            "location": "/spork-inject/migrating-from-dagger/#migrating-from-dagger", 
            "text": "These are the main differences between Dagger and Spork:   Components are replaced by  ObjectGraph  and also depends on module classes  You need to call  Spork.bind(this, objectGraph)  in your object's constructor or initialization method  Provides  and  Lazy  classes are in the  spork.inject  package  No need to annotate your module classes with  @Module  Spork is able to inject  private  fields and methods   Dagger annotations that Spork doesn't support (yet):   @Reusable  @ForReleasableReferences  @BindsOptionalOf", 
            "title": "Migrating from Dagger"
        }, 
        {
            "location": "/spork-android/introduction/", 
            "text": "Spork Android\n\n\nIntroduction\n\n\nSpork Android contains 2 packages:\n\n\n\n\nspork-android\n which provides all basic Android injection\n\n\nspork-android-support\n which provides injection for \nandroid.support.v4.app.Fragment\n\n\n\n\nDependencies\n\n\nAdd the following dependencies in \nbuild.gradle\n:\n\n\nrepositories {\n    jcenter()\n}\n\ndependencies {\n    // Spork core\n    compile 'com.bytewelder.spork:spork:4.0.0'\n\n    // Spork for Android (second line is optional)\n    compile 'com.bytewelder.spork:spork-android:4.0.0@aar'\n\n    // Spork for Android: support libraries (optional)\n    compile 'com.bytewelder.spork:spork-android-support:4.0.0@aar'\n}", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-android/introduction/#spork-android", 
            "text": "", 
            "title": "Spork Android"
        }, 
        {
            "location": "/spork-android/introduction/#introduction", 
            "text": "Spork Android contains 2 packages:   spork-android  which provides all basic Android injection  spork-android-support  which provides injection for  android.support.v4.app.Fragment", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-android/introduction/#dependencies", 
            "text": "Add the following dependencies in  build.gradle :  repositories {\n    jcenter()\n}\n\ndependencies {\n    // Spork core\n    compile 'com.bytewelder.spork:spork:4.0.0'\n\n    // Spork for Android (second line is optional)\n    compile 'com.bytewelder.spork:spork-android:4.0.0@aar'\n\n    // Spork for Android: support libraries (optional)\n    compile 'com.bytewelder.spork:spork-android-support:4.0.0@aar'\n}", 
            "title": "Dependencies"
        }, 
        {
            "location": "/spork-android/annotations/bindclick/", 
            "text": "@BindClick\n\n\nThis annotation can be used with classes inheriting/implementing:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.app.\nFragment\n\n\nandroid.support.v4.app.\nFragment\n (with the \nspork-android-support\n dependency)\n\n\nandroid.view.\nView\n\n\nio.github.sporklibrary.android.interfaces.\nViewProvider\n\n\n\n\nYou can specify the view id as the annotation value:\n\n\n@BindClick(R.id.download_button)\nprivate void onClickDownload() {\n}\n\n\n\n\nAlternatively, you can imply the view id by the method name:\n\n\n@BindClick\nprivate void download_button() {\n}\n\n\n\n\nYou can also pass the any compatible View instance as method argument:\n\n\n@BindClick(R.id.download_button)\nprivate void onClickDownload(Button button) {\n}", 
            "title": "@BindClick"
        }, 
        {
            "location": "/spork-android/annotations/bindclick/#bindclick", 
            "text": "This annotation can be used with classes inheriting/implementing:   android.app. Activity  android.app. Fragment  android.support.v4.app. Fragment  (with the  spork-android-support  dependency)  android.view. View  io.github.sporklibrary.android.interfaces. ViewProvider   You can specify the view id as the annotation value:  @BindClick(R.id.download_button)\nprivate void onClickDownload() {\n}  Alternatively, you can imply the view id by the method name:  @BindClick\nprivate void download_button() {\n}  You can also pass the any compatible View instance as method argument:  @BindClick(R.id.download_button)\nprivate void onClickDownload(Button button) {\n}", 
            "title": "@BindClick"
        }, 
        {
            "location": "/spork-android/annotations/bindfragment/", 
            "text": "@BindFragment\n\n\nThis annotation can be used with classes derived from:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.app.\nFragment\n\n\nandroid.support.v4.app.\nFragment\n (with the \nspork-android-support\n dependency)\n\n\n\n\nYou can bind a fragment by specifying its id:\n\n\n@BindFragment(R.id.my_fragment)\nprivate Fragment myFragment;\n\n\n\n\nAlternatively, you can imply the fragment id by the field name:\n\n\n@BindFragment\nprivate Fragment my_fragment;", 
            "title": "@BindFragment"
        }, 
        {
            "location": "/spork-android/annotations/bindfragment/#bindfragment", 
            "text": "This annotation can be used with classes derived from:   android.app. Activity  android.app. Fragment  android.support.v4.app. Fragment  (with the  spork-android-support  dependency)   You can bind a fragment by specifying its id:  @BindFragment(R.id.my_fragment)\nprivate Fragment myFragment;  Alternatively, you can imply the fragment id by the field name:  @BindFragment\nprivate Fragment my_fragment;", 
            "title": "@BindFragment"
        }, 
        {
            "location": "/spork-android/annotations/bindlayout/", 
            "text": "@BindLayout\n\n\nThis annotation can be used with classes inheriting:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.view.\nViewGroup\n\n\n\n\nWhen using it for \nViewGroup\n, a \nFrameLayout\n is preferred as the inflated layout will be added as a child to it.\n\n\nExample: Activity\n\n\n@BindLayout(R.layout.activity_custom)\npublic class CustomActivity extends Activity {\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this);\n    }\n}\n\n\n\n\nExample: ViewGroup\n\n\n@BindLayout(R.layout.view_custom)\npublic class CustomView extends FrameLayout {\n\n    public MyView(Context context) {\n        super(context);\n        Spork.bind(this);\n    }\n}", 
            "title": "@BindLayout"
        }, 
        {
            "location": "/spork-android/annotations/bindlayout/#bindlayout", 
            "text": "This annotation can be used with classes inheriting:   android.app. Activity  android.view. ViewGroup   When using it for  ViewGroup , a  FrameLayout  is preferred as the inflated layout will be added as a child to it.", 
            "title": "@BindLayout"
        }, 
        {
            "location": "/spork-android/annotations/bindlayout/#example-activity", 
            "text": "@BindLayout(R.layout.activity_custom)\npublic class CustomActivity extends Activity {\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this);\n    }\n}", 
            "title": "Example: Activity"
        }, 
        {
            "location": "/spork-android/annotations/bindlayout/#example-viewgroup", 
            "text": "@BindLayout(R.layout.view_custom)\npublic class CustomView extends FrameLayout {\n\n    public MyView(Context context) {\n        super(context);\n        Spork.bind(this);\n    }\n}", 
            "title": "Example: ViewGroup"
        }, 
        {
            "location": "/spork-android/annotations/bindresource/", 
            "text": "@BindResoure\n\n\nThis annotation can be used with classes inheriting/implementing:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.app.\nApplication\n\n\nandroid.app.\nFragment\n\n\nandroid.app.\nService\n\n\nandroid.content.\nContentProvider\n\n\nandroid.support.v4.app.\nFragment\n (with the \nspork-android-support\n dependency)\n\n\nandroid.view.\nView\n\n\nio.github.sporklibrary.android.interfaces.\nContextProvider\n\n\nio.github.sporklibrary.android.interfaces.\nViewProvider\n\n\n\n\nIt can bind:\n\n\n\n\nR.dimen.*\n to \nFloat\n or \nfloat\n fields\n\n\nR.string.*\n to \nString\n fields\n\n\nR.integer.*\n to \nInteger\n and \nint\n fields\n\n\nR.bool.*\n to \nBoolean\n and \nboolean\n fields\n\n\nR.drawable.*\n to \nDrawable\n fields\n\n\n\n\nYou can bind a resource by specifying its id:\n\n\n@BindResource(R.string.app_name)\nprivate String appName;\n\n\n\n\nAlternatively, you can imply the view id by the field name:\n\n\n@BindResource\nprivate String app_name;\n\n\n\n\nExample\n\n\npublic class MyActivity extends Activity {\n\n    @BindResource(R.string.app_name)\n    private String appName;\n\n    @BindResource\n    private String app_name;\n\n    @BindResource(R.dimen.spork_test_dimension)\n    private float sporkTestDimension;\n\n    @BindResource\n    private Float spork_test_dimension;\n\n    @BindResource(R.drawable.spork_test_drawable)\n    private Drawable sporkTestDrawable;\n\n    @BindResource\n    private Drawable spork_test_drawable;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this);\n    }\n}", 
            "title": "@BindResource"
        }, 
        {
            "location": "/spork-android/annotations/bindresource/#bindresoure", 
            "text": "This annotation can be used with classes inheriting/implementing:   android.app. Activity  android.app. Application  android.app. Fragment  android.app. Service  android.content. ContentProvider  android.support.v4.app. Fragment  (with the  spork-android-support  dependency)  android.view. View  io.github.sporklibrary.android.interfaces. ContextProvider  io.github.sporklibrary.android.interfaces. ViewProvider   It can bind:   R.dimen.*  to  Float  or  float  fields  R.string.*  to  String  fields  R.integer.*  to  Integer  and  int  fields  R.bool.*  to  Boolean  and  boolean  fields  R.drawable.*  to  Drawable  fields   You can bind a resource by specifying its id:  @BindResource(R.string.app_name)\nprivate String appName;  Alternatively, you can imply the view id by the field name:  @BindResource\nprivate String app_name;", 
            "title": "@BindResoure"
        }, 
        {
            "location": "/spork-android/annotations/bindresource/#example", 
            "text": "public class MyActivity extends Activity {\n\n    @BindResource(R.string.app_name)\n    private String appName;\n\n    @BindResource\n    private String app_name;\n\n    @BindResource(R.dimen.spork_test_dimension)\n    private float sporkTestDimension;\n\n    @BindResource\n    private Float spork_test_dimension;\n\n    @BindResource(R.drawable.spork_test_drawable)\n    private Drawable sporkTestDrawable;\n\n    @BindResource\n    private Drawable spork_test_drawable;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this);\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-android/annotations/bindview/", 
            "text": "@BindView\n\n\nThis annotation can be used with classes inheriting/implementing:\n\n\n\n\nandroid.app.\nActivity\n\n\nandroid.app.\nFragment\n\n\nandroid.support.v4.app.\nFragment\n (with the \nspork-android-support\n dependency)\n\n\nandroid.view.\nView\n\n\nio.github.sporklibrary.android.interfaces.\nViewProvider\n\n\n\n\nYou can bind a view by specifying its id:\n\n\n@BindView(R.id.my_button)\nprivate Button button;\n\n\n\n\nAlternatively, you can imply the view id by the field name:\n\n\n@BindView\nprivate Button my_button;", 
            "title": "@BindView"
        }, 
        {
            "location": "/spork-android/annotations/bindview/#bindview", 
            "text": "This annotation can be used with classes inheriting/implementing:   android.app. Activity  android.app. Fragment  android.support.v4.app. Fragment  (with the  spork-android-support  dependency)  android.view. View  io.github.sporklibrary.android.interfaces. ViewProvider   You can bind a view by specifying its id:  @BindView(R.id.my_button)\nprivate Button button;  Alternatively, you can imply the view id by the field name:  @BindView\nprivate Button my_button;", 
            "title": "@BindView"
        }, 
        {
            "location": "/spork-android/examples/application/", 
            "text": "Application\n\n\nIntroduction\n\n\nThe following annotations are supported:\n\n\n\n\n@BindResource\n\n\n@Inject\n\n\n\n\nExample\n\n\npublic class MyApplication extends android.app.Application {\n\n    @BindResource(R.string.app_name)\n    private String appName;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Spork.bind(this);\n    }\n}", 
            "title": "Application"
        }, 
        {
            "location": "/spork-android/examples/application/#application", 
            "text": "", 
            "title": "Application"
        }, 
        {
            "location": "/spork-android/examples/application/#introduction", 
            "text": "The following annotations are supported:   @BindResource  @Inject", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-android/examples/application/#example", 
            "text": "public class MyApplication extends android.app.Application {\n\n    @BindResource(R.string.app_name)\n    private String appName;\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Spork.bind(this);\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-android/examples/activity/", 
            "text": "Activity\n\n\nIntroduction\n\n\nThe following annotations are supported:\n\n\n\n\n@BindClick\n\n\n@BindView\n\n\n@BindLayout\n\n\n@BindResource\n\n\n@BindFragment\n\n\n@Inject\n\n\n\n\nExample\n\n\n@BindLayout(R.layout.activity_download)\npublic class DownloadActivity extends Activity {\n\n    @BindView(R.id.download_button)\n    private Button downloadButton;\n\n    @BindFragment(R.id.details_fragment)\n    private DetailsFragment fragment;\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this); // Spork does its magic\n    }\n\n    @BindClick(R.id.other_button)\n    private void onClickButton(Button someButton) {\n        downloadManager.startDownload();\n    }\n}", 
            "title": "Activity"
        }, 
        {
            "location": "/spork-android/examples/activity/#activity", 
            "text": "", 
            "title": "Activity"
        }, 
        {
            "location": "/spork-android/examples/activity/#introduction", 
            "text": "The following annotations are supported:   @BindClick  @BindView  @BindLayout  @BindResource  @BindFragment  @Inject", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-android/examples/activity/#example", 
            "text": "@BindLayout(R.layout.activity_download)\npublic class DownloadActivity extends Activity {\n\n    @BindView(R.id.download_button)\n    private Button downloadButton;\n\n    @BindFragment(R.id.details_fragment)\n    private DetailsFragment fragment;\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Spork.bind(this); // Spork does its magic\n    }\n\n    @BindClick(R.id.other_button)\n    private void onClickButton(Button someButton) {\n        downloadManager.startDownload();\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-android/examples/contentprovider/", 
            "text": "ContentProvider\n\n\nIntroduction\n\n\nThe following annotations are supported:\n\n\n\n\n@BindResource\n\n\n@Inject\n\n\n\n\nExample\n\n\npublic class CustomContentProvider extends ContentProvider {\n\n    @BindResource(R.string.helloworld)\n    private String helloWorld;\n\n    @Override\n    public boolean onCreate() {\n        Spork.bind(this, new Module());\n        return true;\n    }\n\n    // ContentProvider methods\n}", 
            "title": "ContentProvider"
        }, 
        {
            "location": "/spork-android/examples/contentprovider/#contentprovider", 
            "text": "", 
            "title": "ContentProvider"
        }, 
        {
            "location": "/spork-android/examples/contentprovider/#introduction", 
            "text": "The following annotations are supported:   @BindResource  @Inject", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-android/examples/contentprovider/#example", 
            "text": "public class CustomContentProvider extends ContentProvider {\n\n    @BindResource(R.string.helloworld)\n    private String helloWorld;\n\n    @Override\n    public boolean onCreate() {\n        Spork.bind(this, new Module());\n        return true;\n    }\n\n    // ContentProvider methods\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-android/examples/fragment/", 
            "text": "Fragment\n\n\nIntroduction\n\n\nYou can also use \nandroid.support.v4.app.Fragment\n if you add the \nspork-android-support\n dependency.\n\n\nThe following annotations are supported:\n\n\n\n\n@BindClick\n\n\n@BindView\n\n\n@BindResource\n\n\n@BindFragment\n\n\n@Inject\n\n\n\n\nExample\n\n\npublic class MyFragment extends Fragment {\n\n    @BindView(R.id.some_textview)\n    private TextView myTextView;\n\n    @Override\n    public View onCreateView(LayoutInflater inflater,\n        @Nullable ViewGroup container, Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_click_binding, container);\n    }\n\n    @Override\n    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {\n        Spork.bind(this);\n    }\n\n    @BindClick(R.id.some_button)\n    private void onClick() {\n        // click-handling code goes here\n    }\n}", 
            "title": "Fragment"
        }, 
        {
            "location": "/spork-android/examples/fragment/#fragment", 
            "text": "", 
            "title": "Fragment"
        }, 
        {
            "location": "/spork-android/examples/fragment/#introduction", 
            "text": "You can also use  android.support.v4.app.Fragment  if you add the  spork-android-support  dependency.  The following annotations are supported:   @BindClick  @BindView  @BindResource  @BindFragment  @Inject", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-android/examples/fragment/#example", 
            "text": "public class MyFragment extends Fragment {\n\n    @BindView(R.id.some_textview)\n    private TextView myTextView;\n\n    @Override\n    public View onCreateView(LayoutInflater inflater,\n        @Nullable ViewGroup container, Bundle savedInstanceState) {\n        return inflater.inflate(R.layout.fragment_click_binding, container);\n    }\n\n    @Override\n    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {\n        Spork.bind(this);\n    }\n\n    @BindClick(R.id.some_button)\n    private void onClick() {\n        // click-handling code goes here\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-android/examples/recyclerview/", 
            "text": "RecyclerView\n\n\nIntroduction\n\n\nTo bind \nRecyclerView\n views, you need to make \nRecyclerView.ViewHolder\n implement \nio.github.sporklibrary.android.interfaces.ViewProvider\n.\n\n\nThe following annotations are supported:\n\n\n\n\n@BindView\n\n\n@BindClick\n\n\n@BindResource\n\n\n@Inject\n\n\n\n\nExample\n\n\npublic class MyAdapter extends RecyclerView.Adapter\nMyAdapter.MyViewHolder\n {\n    private final List\nString\n items;\n\n    public MyAdapter(List\nString\n items) {\n        this.items = items;\n    }\n\n    public class MyViewHolder extends RecyclerView.ViewHolder implements ViewProvider {\n\n        @BindView(R.id.textview)\n        private TextView textView;\n\n        public MyViewHolder(View itemView) {\n            super(itemView);\n            Spork.bind(this);\n        }\n\n        public void update(String text) {\n            textView.setText(text);\n        }\n\n        @BindClick(R.id.textview)\n        private void onClick() {\n            // ...\n        }\n\n        @Override\n        public View getView() {\n            return itemView;\n        }\n    }\n\n    @Override\n    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        LayoutInflater inflater = LayoutInflater.from(parent.getContext());\n        View view = inflater.inflate(R.layout.view_recyclerview_item, parent, false);\n        return new MyViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(MyViewHolder holder, int position) {\n        String item = items.get(position);\n        holder.update(item);\n    }\n\n    @Override\n    public int getItemCount() {\n        return items.size();\n    }\n}", 
            "title": "RecyclerView"
        }, 
        {
            "location": "/spork-android/examples/recyclerview/#recyclerview", 
            "text": "", 
            "title": "RecyclerView"
        }, 
        {
            "location": "/spork-android/examples/recyclerview/#introduction", 
            "text": "To bind  RecyclerView  views, you need to make  RecyclerView.ViewHolder  implement  io.github.sporklibrary.android.interfaces.ViewProvider .  The following annotations are supported:   @BindView  @BindClick  @BindResource  @Inject", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-android/examples/recyclerview/#example", 
            "text": "public class MyAdapter extends RecyclerView.Adapter MyAdapter.MyViewHolder  {\n    private final List String  items;\n\n    public MyAdapter(List String  items) {\n        this.items = items;\n    }\n\n    public class MyViewHolder extends RecyclerView.ViewHolder implements ViewProvider {\n\n        @BindView(R.id.textview)\n        private TextView textView;\n\n        public MyViewHolder(View itemView) {\n            super(itemView);\n            Spork.bind(this);\n        }\n\n        public void update(String text) {\n            textView.setText(text);\n        }\n\n        @BindClick(R.id.textview)\n        private void onClick() {\n            // ...\n        }\n\n        @Override\n        public View getView() {\n            return itemView;\n        }\n    }\n\n    @Override\n    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        LayoutInflater inflater = LayoutInflater.from(parent.getContext());\n        View view = inflater.inflate(R.layout.view_recyclerview_item, parent, false);\n        return new MyViewHolder(view);\n    }\n\n    @Override\n    public void onBindViewHolder(MyViewHolder holder, int position) {\n        String item = items.get(position);\n        holder.update(item);\n    }\n\n    @Override\n    public int getItemCount() {\n        return items.size();\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-android/examples/service/", 
            "text": "Service\n\n\nIntroduction\n\n\nThe following annotations are supported:\n\n\n\n\n@BindResource\n\n\n@Inject\n\n\n\n\nExample\n\n\npublic class TestService extends Service {\n    @BindResource(R.string.helloworld)\n    private String helloWorld;\n\n    public class LocalBinder extends Binder {\n        public TestService getLocalService() {\n            return TestService.this;\n        }\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Spork.bind(this);\n    }\n\n    @Override\n    public @Nullable IBinder onBind(Intent intent) {\n        return new LocalBinder();\n    }\n}", 
            "title": "Service"
        }, 
        {
            "location": "/spork-android/examples/service/#service", 
            "text": "", 
            "title": "Service"
        }, 
        {
            "location": "/spork-android/examples/service/#introduction", 
            "text": "The following annotations are supported:   @BindResource  @Inject", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-android/examples/service/#example", 
            "text": "public class TestService extends Service {\n    @BindResource(R.string.helloworld)\n    private String helloWorld;\n\n    public class LocalBinder extends Binder {\n        public TestService getLocalService() {\n            return TestService.this;\n        }\n    }\n\n    @Override\n    public void onCreate() {\n        super.onCreate();\n        Spork.bind(this);\n    }\n\n    @Override\n    public @Nullable IBinder onBind(Intent intent) {\n        return new LocalBinder();\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-android/examples/view/", 
            "text": "View\n\n\nIntroduction\n\n\nWhen creating a custom view, it's best to extend a \nFrameLayout\n, because \n@BindLayout\n will inflate the specified layout into it.\n\n\nThe following annotations are supported:\n\n\n\n\n@BindClick\n\n\n@BindView\n\n\n@BindLayout\n\n\n@BindResource\n\n\n@Inject\n\n\n\n\nExample\n\n\n@BindLayout(R.layout.view_layout_binding)\npublic class MyView extends FrameLayout {\n\n    @BindView(R.id.textview)\n    private TextView textView;\n\n    public MyView(Context context) {\n        super(context);\n        // Note: Spork.bind() must be called in \n        // all constructors that are implemented!\n        Spork.bind(this);\n    }\n\n    @BindClick(R.id.button_one)\n    private void onClickDownload() {\n        // ...\n    }\n\n    // BindClick can also pass the button that was clicked\n    @BindClick(R.id.button_two)\n    private void onClickOtherButton(Button otherButton) {\n        // ...\n    }\n}", 
            "title": "View"
        }, 
        {
            "location": "/spork-android/examples/view/#view", 
            "text": "", 
            "title": "View"
        }, 
        {
            "location": "/spork-android/examples/view/#introduction", 
            "text": "When creating a custom view, it's best to extend a  FrameLayout , because  @BindLayout  will inflate the specified layout into it.  The following annotations are supported:   @BindClick  @BindView  @BindLayout  @BindResource  @Inject", 
            "title": "Introduction"
        }, 
        {
            "location": "/spork-android/examples/view/#example", 
            "text": "@BindLayout(R.layout.view_layout_binding)\npublic class MyView extends FrameLayout {\n\n    @BindView(R.id.textview)\n    private TextView textView;\n\n    public MyView(Context context) {\n        super(context);\n        // Note: Spork.bind() must be called in \n        // all constructors that are implemented!\n        Spork.bind(this);\n    }\n\n    @BindClick(R.id.button_one)\n    private void onClickDownload() {\n        // ...\n    }\n\n    // BindClick can also pass the button that was clicked\n    @BindClick(R.id.button_two)\n    private void onClickOtherButton(Button otherButton) {\n        // ...\n    }\n}", 
            "title": "Example"
        }, 
        {
            "location": "/spork-android/proguard/", 
            "text": "ProGuard \n DexGuard\n\n\nProGuard's shrinking process might remove your components, because they are instantiated by reflection instead of the regular way. To avoid this, you need to specify the classes and interfaces to keep in your proguard configuration.\n\n\nThis includes:\n\n\n\n\nAny injected dependencies with \n@Inject\n\n\nModules\n\n\n\n\nSpork itself already includes a ProGuard file that keeps all Spork-related classes.\nSpork is very lightweight, so the impact on your method and field count will be very limited.\n\n\nExample\n\n\nYou can ensure that your classes and interfaces are kept as follows:\n\n\n-keep class com.yourapp.modules.** { *; }\n-keep interface com.yourapp.interfaces.** { *; }", 
            "title": "ProGuard"
        }, 
        {
            "location": "/spork-android/proguard/#proguard-dexguard", 
            "text": "ProGuard's shrinking process might remove your components, because they are instantiated by reflection instead of the regular way. To avoid this, you need to specify the classes and interfaces to keep in your proguard configuration.  This includes:   Any injected dependencies with  @Inject  Modules   Spork itself already includes a ProGuard file that keeps all Spork-related classes.\nSpork is very lightweight, so the impact on your method and field count will be very limited.", 
            "title": "ProGuard &amp; DexGuard"
        }, 
        {
            "location": "/spork-android/proguard/#example", 
            "text": "You can ensure that your classes and interfaces are kept as follows:  -keep class com.yourapp.modules.** { *; }\n-keep interface com.yourapp.interfaces.** { *; }", 
            "title": "Example"
        }
    ]
}