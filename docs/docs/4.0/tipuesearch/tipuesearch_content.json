{"pages":[{"title":"Spork 4.0 Documentation","text":"Getting started on Android WARNING: Spork 4.0 is only accessible as a snapshot release.This is not a final release and is subject to potential changes in its API. Add the following dependencies in build.gradle: repositories { maven { url &quot;http:\/\/dl.bintray.com\/bytewelder\/maven-snapshot&quot; } } dependencies { \/\/ Spork core compile 'com.bytewelder.spork:spork:4.0.0' \/\/ Spork Dependency Injection compile 'com.bytewelder.spork:spork-inject:4.0.0' \/\/ Spork for Android (second line is optional) compile 'com.bytewelder.spork:spork-android:4.0.0@aar' compile 'com.bytewelder.spork:spork-android-support:4.0.0@aar' } Getting started on Java Add the following dependencies in build.gradle: dependencies { compile 'com.bytewelder.spork:spork:4.0.0' compile 'com.bytewelder.spork:spork-inject:4.0.0' } All dependencies are available at Maven Central Repository. Migrating from 3.x to 4.0: repository is moved to jCenter with snapshots at http:\/\/dl.bintray.com\/bytewelder\/maven-snapshot base packages moved from io.github.sporklibrary to spork @BindComponent is now @Inject and injection is done with dependencies defined by an ObjectGraph and its modules. @ComponentScope(Scope.SINGLETON) is now @Singleton removed custom support for RecyclerView.ViewHolder as you can now make it implement ViewProvider FieldBinder, MethodBinder and TypeBinder interfaces are changed","tags":"","url":"index.html"},{"title":"Introduction","text":"Spork for Android Spork for Android has 2 packages: spork-android which provides all basic Android injection spork-android-support which provides injection for android.support.v4.app.Fragment Dependencies Add the following dependencies in build.gradle: repositories { jcenter() } dependencies { \/\/ Spork core compile 'com.bytewelder.spork:spork:4.0.0' \/\/ Spork for Android (second line is optional) compile 'com.bytewelder.spork:spork-android:4.0.0@aar' \/\/ Spork for Android: support libraries (optional) compile 'com.bytewelder.spork:spork-android-support:4.0.0@aar' }","tags":"","url":"Android\/Introduction.html"},{"title":"BindClick","text":"@BindClick This annotation can be used with classes inheriting\/implementing: android.app.Activity android.app.Fragment android.support.v4.app.Fragment (with the spork-android-support dependency) android.view.View io.github.sporklibrary.android.interfaces.ViewProvider You can specify the view id as the annotation value: @BindClick(R.id.download_button) private void onClickDownload() { } Alternatively, you can imply the view id by the method name: @BindClick private void download_button() { } You can also pass the any compatible View instance as method argument: @BindClick(R.id.download_button) private void onClickDownload(Button button) { }","tags":"","url":"Android\/Annotations\/BindClick.html"},{"title":"BindFragment","text":"@BindFragment This annotation can be used with classes derived from: android.app.Activity android.app.Fragment android.support.v4.app.Fragment (with the spork-android-support dependency) You can bind a fragment by specifying its id: @BindFragment(R.id.my_fragment) private Fragment myFragment; Alternatively, you can imply the fragment id by the field name: @BindFragment private Fragment my_fragment;","tags":"","url":"Android\/Annotations\/BindFragment.html"},{"title":"BindLayout","text":"@BindLayout This annotation can be used with classes inheriting: android.app.Activity android.view.ViewGroup When using it for ViewGroup, a FrameLayout is preferred as the inflated layout will be added as a child to it. Example: Activity @BindLayout(R.layout.activity_custom) public class CustomActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); } } Example: ViewGroup @BindLayout(R.layout.view_custom) public class CustomView extends FrameLayout { public MyView(Context context) { super(context); Spork.bind(this); } }","tags":"","url":"Android\/Annotations\/BindLayout.html"},{"title":"BindResource","text":"@BindResoure This annotation can be used with classes inheriting\/implementing: android.app.Activity android.app.Application android.app.Fragment android.app.Service android.content.ContentProvider android.support.v4.app.Fragment (with the spork-android-support dependency) android.view.View io.github.sporklibrary.android.interfaces.ContextProvider io.github.sporklibrary.android.interfaces.ViewProvider It can bind: R.dimen.* to Float or float fields R.string.* to String fields R.integer.* to Integer and int fields R.bool.* to Boolean and boolean fields R.drawable.* to Drawable fields You can bind a resource by specifying its id: @BindResource(R.string.app_name) private String appName; Alternatively, you can imply the view id by the field name: @BindResource private String app_name; Example public class MyActivity extends Activity { @BindResource(R.string.app_name) private String appName; @BindResource private String app_name; @BindResource(R.dimen.spork_test_dimension) private float sporkTestDimension; @BindResource private Float spork_test_dimension; @BindResource(R.drawable.spork_test_drawable) private Drawable sporkTestDrawable; @BindResource private Drawable spork_test_drawable; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); } }","tags":"","url":"Android\/Annotations\/BindResource.html"},{"title":"BindView","text":"@BindView This annotation can be used with classes inheriting\/implementing: android.app.Activity android.app.Fragment android.support.v4.app.Fragment (with the spork-android-support dependency) android.view.View io.github.sporklibrary.android.interfaces.ViewProvider You can bind a view by specifying its id: @BindView(R.id.my_button) private Button button; Alternatively, you can imply the view id by the field name: @BindView private Button my_button;","tags":"","url":"Android\/Annotations\/BindView.html"},{"title":"Activity","text":"Activity Introduction The following annotations are supported: @BindClick @BindView @BindLayout @BindResource @BindFragment @Inject Example @BindLayout(R.layout.activity_download) public class DownloadActivity extends Activity { @BindView(R.id.download_button) private Button downloadButton; @BindFragment(R.id.details_fragment) private DetailsFragment fragment; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); \/\/ Spork does its magic } @BindClick(R.id.other_button) private void onClickButton(Button someButton) { downloadManager.startDownload(); } }","tags":"","url":"Android\/Examples\/Activity.html"},{"title":"Application","text":"Application Introduction The following annotations are supported: @BindResource @Inject Example public class MyApplication extends android.app.Application { @BindResource(R.string.app_name) private String appName; @Override public void onCreate() { super.onCreate(); Spork.bind(this); } }","tags":"","url":"Android\/Examples\/Application.html"},{"title":"ContentProvider","text":"ContentProvider Introduction The following annotations are supported: @BindResource @Inject Example public class CustomContentProvider extends ContentProvider { @BindResource(R.string.helloworld) private String helloWorld; @Override public boolean onCreate() { Spork.bind(this, new Module()); return true; } \/\/ ContentProvider methods }","tags":"","url":"Android\/Examples\/ContentProvider.html"},{"title":"Fragment","text":"Fragment Introduction You can also use android.support.v4.app.Fragment if you add the spork-android-support dependency. The following annotations are supported: @BindClick @BindView @BindResource @BindFragment @Inject Example public class MyFragment extends Fragment { @BindView(R.id.some_textview) private TextView myTextView; @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_click_binding, container); } @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { Spork.bind(this); } @BindClick(R.id.some_button) private void onClick() { \/\/ click-handling code goes here } }","tags":"","url":"Android\/Examples\/Fragment.html"},{"title":"RecyclerView","text":"RecyclerView Introduction To bind RecyclerView views, you need to make RecyclerView.ViewHolder implement io.github.sporklibrary.android.interfaces.ViewProvider. The following annotations are supported: @BindView @BindClick @BindResource @Inject Example public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private final List&lt;String&gt; items; public MyAdapter(List&lt;String&gt; items) { this.items = items; } public class MyViewHolder extends RecyclerView.ViewHolder implements ViewProvider { @BindView(R.id.textview) private TextView textView; public MyViewHolder(View itemView) { super(itemView); Spork.bind(this); } public void update(String text) { textView.setText(text); } @BindClick(R.id.textview) private void onClick() { \/\/ ... } @Override public View getView() { return itemView; } } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View view = inflater.inflate(R.layout.view_recyclerview_item, parent, false); return new MyViewHolder(view); } @Override public void onBindViewHolder(MyViewHolder holder, int position) { String item = items.get(position); holder.update(item); } @Override public int getItemCount() { return items.size(); } }","tags":"","url":"Android\/Examples\/RecyclerView.html"},{"title":"Service","text":"Service Introduction The following annotations are supported: @BindResource @Inject Example public class TestService extends Service { @BindResource(R.string.helloworld) private String helloWorld; public class LocalBinder extends Binder { public TestService getLocalService() { return TestService.this; } } @Override public void onCreate() { super.onCreate(); Spork.bind(this); } @Override public @Nullable IBinder onBind(Intent intent) { return new LocalBinder(); } }","tags":"","url":"Android\/Examples\/Service.html"},{"title":"View","text":"View Introduction When creating a custom view, it's best to extend a FrameLayout, because @BindLayout will inflate the specified layout into it. The following annotations are supported: @BindClick @BindView @BindLayout @BindResource @Inject Example @BindLayout(R.layout.view_layout_binding) public class MyView extends FrameLayout { (R.id.textview) private TextView textView; public MyView(Context context) { super(context); \/\/ Note: Spork.bind() must be called in \/\/ all constructors that are implemented! Spork.bind(this); } @BindClick(R.id.button_one) private void onClickDownload() { \/\/ ... } \/\/ BindClick can also pass the button that was clicked @BindClick(R.id.button_two) private void onClickOtherButton(Button otherButton) { \/\/ ... } }","tags":"","url":"Android\/Examples\/View.html"},{"title":"ProGuard","text":"ProGuard &amp; DexGuard ProGuard's shrinking process might remove your dependencies, because they are indirectly instantiated by means of reflection. To avoid this, you need to specify the classes and interfaces to keep in your proguard configuration. Example You can ensure that your classes and interfaces are kept in an Android ProGuard\/DexGuard configuration file: -keep class com.yourapp.modules.** { *; } -keep interface com.yourapp.interfaces.** { *; }","tags":"","url":"Android\/ProGuard.html"},{"title":"Introduction","text":"Spork Inject Spork Inject is a runtime dependency injection framework for Java and Android. It is almost fully compatible with Dagger and is modeled on the JSR-330 specification. Dependencies Add the following dependencies in build.gradle: repositories { jcenter() } dependencies { compile 'com.bytewelder.spork:spork:4.0.0' compile 'com.bytewelder.spork:spork-inject:4.0.0' } Example public static class Module { @Provides public Integer provideNumber() { return 1; } @Provides @Named(&quot;color&quot;) public String provideColor() { return &quot;red&quot;; } @Provides @Named(&quot;label&quot;) public String provideLabel() { return &quot;Hi!&quot;; } @Provides @Singleton public RestService provideRestService(HttpService service) { return new RestServiceImpl(service); } @Provides @Singleton public HttpService provideHttpService() { return new HttpServiceImpl(service); } } private static class Parent { @Inject private Integer number; @Inject @Named(&quot;color&quot;) private String color; @Inject @Named(&quot;label&quot;) private String label; @Inject private RestService restService; public Parent() { ObjectGraph graph = new ObjectGraph.Builder() .module(new Module()) .build(); Spork.bind(this, graph); } }","tags":"","url":"Dependency_Injection\/Introduction.html"},{"title":"User Guide","text":"User Guide Using Spork Inject Spork creates instances of your classes and satisfies their dependencies. It uses the javax.inject.Inject annotation to identify which constructors and fields it is interested in. Use Spork.bind() in constructor or initialization methods so Spork can create instances of the dependencies. When a new instance is requested, Spork will obtain the required parameters values and invoke its constructor. class Car implements Vehicle { private Engine engine; private Driver driver; @Inject Car(Engine engine, Driver driver) { this.engine = engine; this.driver = driver; } } Spork can inject fields directly. In this example it obtains an Engine and a Driver instance for the respective fields: class Car { @Inject private Engine engine; @Inject private Driver driver; ... } Spork also supports method injection, but Field injection is generally preferred. Declaring Dependencies In the above sample, an Engine and Driver are injected. Of course these dependencies must come from somewhere. Dependencies should be defined in a Module as follows: @Provides Engine provideEngine() { return new DieselEngine(); } It's possible for a @Provides method to require dependencies on its own: @Provides Engine provideEngine(Piston piston) { return new DieselEngine(piston); } @Provides Piston providePiston() { return new StrongPiston(); } Modules The @Provides-annotated methods above are placed in a Module. Modules are POJO objects that define a set of dependencies: class CarModule { @Provides Engine provideEngine(Piston piston) { return new DieselEngine(piston); } @Provides Piston providePiston() { return new StrongPiston(); } } Building an ObjectGraph A module is used to build an object graph. Object graphs hold state such as your singletons and named instances. Creating an ObjectGraph is easy: ObjectGraph objectGraph = new ObjectGraph.Builder() .module(new CarModule()) .build(); An ObjectGraph is then used to inject an instance: class Car { @Inject Engine engine; @Inject Driver driver; public Car() { Spork.bind(this, objectGraph); } } When putting it all together, the car from the sample above could be injected as follows: class Car { @Inject private Engine engine; @Inject private Driver driver; public Car() { ObjectGraph objectGraph = new ObjectGraph.Builder() .module(new CarModule()) .build() .inject(this); } } ObjectGraph with parent An object graph can have a parent object graph: ObjectGraph objectGraph = new ObjectGraph.Builder(applicationObjectGraph) .module(new CarModule()) .build(); This way, it can resolve dependencies from its parent and from the CarModule. An ObjectGraph's modules can override the dependencies of the parent as long as the injection signature is an exact match: its type, qualifier and nullability must match. Singletons and Scoped bindings Module methods annotated with @Provides can also have scope annotations. Scopes can be custom-made, but @Singleton is one that is available by default. It can be used like this: @Provides @Singleton UserService provideUserService() { return new UserServiceImpl(); } Scoped instances such as the singleton instance above are associated with the ObjectGraph that the Module belongs to. This means that their scope is only valid for objects injected with that ObjectGraph. Lazy injection Instead of injecting an instance directly, they can also injected on a Lazy&lt;T&gt; field. When get() is called on the Lazy field, it will retrieve the injected instance from the module. Calling get() multiple times will return the same instances every time. class Car { @Inject private Lazy&lt;Engine&gt; engine; public Car() { ... engine.get().start(); } } Provider injection A Provider&lt;T&gt; is similar to a Lazy&lt;T&gt; field, but injects a new instance every time it is called. Injecting Provider&lt;T&gt; is generally not advised. You might want to use the factory pattern instead or re-organize your logic and use a Lazy&lt;T&gt; field instead. class Car { @Inject private Provider&lt;Engine&gt; engine; public Car() { ... engine.get().start(); } } Qualifiers Sometimes it is not sufficient to bind by type alone. In such cases, you might want to identify an injection by some kind of identifier. In such cases, you can define a new annotation and add to it a @Qualifier annotation. Named The @Named annotation is one that is available by default: @Qualifier @Documented @Retention(RUNTIME) public @interface Named { String value() default &quot;&quot;; } A module is then available to provide named injections: class CarModule { @Provides @Named(&quot;driver&quot;) public Seat provideDriverSeat() { ... } @Provides @Named(&quot;passenger&quot;) public Seat providePassengerSeat() { ... } } This module can then be used to inject a Car: class Car { @Inject @Named(&quot;driver&quot;) Seat driverSeat; @Inject @Named(&quot;passenger&quot;) Seat passengerSeat; ... } Custom qualifiers You can also define your own qualifiers. For example: @Qualifier @Documented @Retention(RUNTIME) public @interface Colored { Color value() default Color.WHITE; } After defining the annotation, we have to define how it can serialize into a unique identifier: AnnotationSerializerRegistry.register(Colored.class, new ColoredSerializer()); Adding spork to your project repositories { jcenter() } dependencies { compile 'com.bytewelder.spork:spork-inject:4.0.0' } Note: Before release, spork-inject is available at maven repository http:\/\/dl.bintray.com\/bytewelder\/maven-snapshot License Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in compliance with the License. You may obtain a copy of the License at http:\/\/www.apache.org\/licenses\/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","tags":"","url":"Dependency_Injection\/User_Guide.html"},{"title":"Migrating from Dagger","text":"Migrating from Dagger These are the main differences between Dagger and Spork: Components are replaced by ObjectGraph and also depends on module classes Provides and Lazy classes are in the spork.inject package No need to annotate your module classes with @Module Spork is able to inject private fields and methods Dagger annotations that Spork doesn't support (yet): @Reusable @ForReleasableReferences @BindsOptionalOf","tags":"","url":"Dependency_Injection\/Migrating_from_Dagger.html"},{"title":"Introduction","text":"Spork Core Spork Core contains the basic building blocks where the other Spork libraries are built upon. It is provides annotation processing interfaces for classes(&quot;types&quot;), fields and methods. Dependencies Add the following dependencies in build.gradle: repositories { jcenter() } dependencies { compile 'com.bytewelder.spork:spork:4.0.0' }","tags":"","url":"Annotation_Development\/Introduction.html"},{"title":"Creating Annotations","text":"Creating Annotations Overview Spork annotations are bound through one or more of: MethodBinder FieldBinder TypeBinder These binders are registered through a BinderRegistery which is accessible through Spork.sharedInstance().getBinderRegistry() FieldBinder FieldBinders are used for annotations that target ElementType.FIELD. Example public class BindViewBinder implements FieldBinder&lt;BindView&gt; { @Override public void bind(Object object, BindView annotation, Field field, Object[] modules) { if (!View.class.isAssignableFrom(field.getType())) { throw new BindException(\/* ... *\/); } View view = Views.getView(viewResolver, annotation.value(), field.getName(), object); Reflection.setFieldValue(annotation, field, object, view); } @Override public Class&lt;BindView&gt; getAnnotationClass() { return BindView.class; } } MethodBinder MethodBinders are used for annotations that target ElementType.METHOD. Example public class BindClickBinder implements MethodBinder&lt;BindClick&gt; { @Override public void bind(Object object, BindClick annotation, Method method, @Nullable Object[] modules) { View view = Views.getView(viewResolver, annotation.value(), method.getName(), object); view.setOnClickListener(new OnClickListener() { \/* handle click *\/ }); } @Override public Class&lt;BindClick&gt; getAnnotationClass() { return BindClick.class; } } TypeBinder TypeBinders are used for annotations that target ElementType.TYPE. Example public interface IntSettable { void setValue(int value); } public class ValueBinder implements TypeBinder&lt;BindValue&gt; { @Override void bind(Object object, IntSettable annotation, Class&lt;?&gt; annotatedType, Object[] modules) { \/\/ @BindValue only works with IntSettable implementations if (!IntSettable.class.isAssignableFrom(object.getClass())) { throw new BindException(\/* ... *\/); } \/\/ Safely convert to IntSettable IntSettable value_holder = (IntSettable)object; \/\/ Set the integer value int value = annotatedClass.getAnnotation().value(); value_holder.setValue(value); } @Override public Class&lt;BindValue&gt; getAnnotationClass() { return BindValue.class; } } Binder registration Single target binders For binders that only bind to a single annotation target (e.g. ElementType.FIELD, ElementType.METHOD or ElementType.TYPE). The following code demonstrates this. YourAnnotation.java @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface YourAnnotation { } YourAnnotationBinder.java class YourAnnotationBinder implements MethodBinder&lt;YourAnnotation&gt; { \/\/ implementation } Main.java Spork.sharedInstance().getBinderRegistry().register(new YourAnnotationBinder()); Multi-target binders For binders that only bind to multiple annotation targets (e.g. ElementType.FIELD, ElementType.METHOD or ElementType.TYPE). The following code demonstrates this. YourAnnotation.java @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.METHOD, Element.FIELD }) public @interface YourAnnotation { } YourAnnotationBinder.java class YourAnnotationBinder implements MethodBinder&lt;YourAnnotation&gt;, FieldBinder&lt;YourAnnotation&gt; { \/\/ implementation } Main.java YourAnnotationBinder binder = new YourAnnotationBinder(); \/\/ register as MethodBinder Spork.sharedInstance().getBinderRegistry().register((MethodBinder&lt;YourAnnotation&gt;)binder); \/\/ register as FieldBinder Spork.sharedInstance().getBinderRegistry().register((FieldBinder&lt;YourAnnotation&gt;)binder);","tags":"","url":"Annotation_Development\/Creating_Annotations.html"}]}