{"pages":[{"title":"Spork 3.0 Documentation","text":"Getting started Add the following dependencies in build.gradle: dependencies { \/\/ Spork core, including component injection compile 'io.github.sporklibrary:spork:3.2.0' \/\/ Spork for Android compile 'io.github.sporklibrary:spork-android:3.0.0@aar' \/\/ Optional: Spork Android support\/compat library bindings (e.g. support Fragment injection) \/\/ It requires you to also add: appcompat-v7, support-v4, recyclerview-v7 compile 'io.github.sporklibrary:spork-android-support:3.0.0@aar' } All dependencies are available at Maven Central Repository. Upgrading from 2.x to 3.x: Spork Android has changed its files from io.github.sporklibrary to io.github.sporklibrary.android There are separate dependencies for the Android support\/compat libraries as defined above.","tags":"","url":"index.html"},{"title":"BindClick","text":"@BindClick This annotation can be used with classes derived from: android.app.Activity android.app.Fragment android.support.v4.app.Fragment android.support.v7.widget.RecyclerView.ViewHolder android.view.View You can specify the view id as the annotation value: @BindClick(R.id.download_button) private void onClickDownload() { } Alternatively, you can imply the view id by the method name: @BindClick private void download_button() { } You can also pass the any compatible View instance as method argument: @BindClick(R.id.download_button) private void onClickDownload(Button button) { }","tags":"","url":"Android\/Annotations\/BindClick.html"},{"title":"BindFragment","text":"@BindFragment This annotation can be used with classes derived from: android.app.Activity android.app.Fragment android.support.v4.app.Fragment You can bind a fragment by specifying its id: @BindFragment(R.id.my_fragment) private Fragment myFragment; Alternatively, you can imply the fragment id by the field name: @BindFragment private Fragment my_fragment;","tags":"","url":"Android\/Annotations\/BindFragment.html"},{"title":"BindLayout","text":"@BindLayout This annotation can be used with classes derived from: android.app.Activity android.view.ViewGroup When using it for ViewGroup, a FrameLayout is preferred as the inflated layout will be added as a child to it. Example: Activity @BindLayout(R.layout.activity_custom) public class CustomActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); } } Example: ViewGroup @BindLayout(R.layout.view_custom) public class CustomView extends FrameLayout { public MyView(Context context) { super(context); Spork.bind(this); } }","tags":"","url":"Android\/Annotations\/BindLayout.html"},{"title":"BindResource","text":"@BindResoure This annotation can be used with classes derived from: android.app.Activity android.app.Application android.app.Fragment android.app.Service android.content.ContentProvider android.support.v4.app.Fragment android.support.v7.widget.RecyclerView.ViewHolder android.view.View io.github.sporklibrary.interfaces.ContextProvider It can bind: R.dimen.* to Float or float fields R.string.* to String fields R.drawable.* to Drawable fields You can bind a resource by specifying its id: @BindResource(R.string.app_name) private String appName; Alternatively, you can imply the view id by the field name: @BindResource private String app_name; Example public class MyActivity extends Activity { @BindResource(R.string.app_name) private String appName; @BindResource private String app_name; @BindResource(R.dimen.spork_test_dimension) private float sporkTestDimension; @BindResource private Float spork_test_dimension; @BindResource(R.drawable.spork_test_drawable) private Drawable sporkTestDrawable; @BindResource private Drawable spork_test_drawable; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); } }","tags":"","url":"Android\/Annotations\/BindResource.html"},{"title":"BindView","text":"@BindView This annotation can be used with classes derived from: android.app.Activity android.app.Fragment android.support.v4.app.Fragment android.support.v7.widget.RecyclerView.ViewHolder android.view.View You can bind a view by specifying its id: @BindView(R.id.my_button) private Button button; Alternatively, you can imply the view id by the field name: @BindView private Button my_button;","tags":"","url":"Android\/Annotations\/BindView.html"},{"title":"Activity","text":"Activity Introduction Both Activity and AppCompatActivity are supported. The following annotations are supported: @BindClick @BindView @BindLayout @BindResource @BindFragment @BindComponent Example @BindLayout(R.layout.activity_download) public class DownloadActivity extends Activity { @BindView(R.id.download_button) private Button downloadButton; @BindFragment(R.id.details_fragment) private DetailsFragment fragment; @BindComponent private DownloadManager downloadManager; public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); \/\/ Spork does its magic } @BindClick(R.id.other_button) private void onClickButton(Button someButton) { downloadManager.startDownload(); } } @ComponentScope(scope = ComponentScope.Scope.SINGLETON) public class DownloadManager { public void startDownload() {} }","tags":"","url":"Android\/Examples\/Activity.html"},{"title":"Application","text":"Application Introduction The following annotations are supported: @BindResource @BindComponent Example public class MyApplication extends android.app.Application { @BindComponent private MyComponent component; @BindResource(R.string.app_name) private String appName; @Override public void onCreate() { super.onCreate(); Spork.bind(this); } } public class MyComponent { }","tags":"","url":"Android\/Examples\/Application.html"},{"title":"ContentProvider","text":"ContentProvider Introduction The following annotations are supported: @BindResource @BindComponent Example public class CustomContentProvider extends ContentProvider { @BindComponent private SomeComponent component; @Override public boolean onCreate() { Spork.bind(this); return true; } \/\/ ContentProvider methods }","tags":"","url":"Android\/Examples\/ContentProvider.html"},{"title":"Fragment","text":"Fragment Introduction Both android.app.Fragment and android.support.v4.app.Fragment are supported. The following annotations are supported: @BindClick @BindView @BindResource @BindFragment @BindComponent Example public class MyFragment extends Fragment { @BindView(R.id.some_textview) private TextView myTextView; @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) { return inflater.inflate(R.layout.fragment_click_binding, container); } @Override public void onViewCreated(View view, @Nullable Bundle savedInstanceState) { Spork.bind(this); } @BindClick(R.id.some_button) private void onClick() { \/\/ click-handling code goes here } }","tags":"","url":"Android\/Examples\/Fragment.html"},{"title":"RecyclerView","text":"RecyclerView Introduction To bind RecyclerView views, you need to bind the RecyclerView.ViewHolder. The following annotations are supported: @BindView @BindClick @BindResource @BindComponent Example public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; { private final List&lt;String&gt; items; public MyAdapter(List&lt;String&gt; items) { this.items = items; } public class MyViewHolder extends RecyclerView.ViewHolder { @BindView(R.id.textview) private TextView textView; public MyViewHolder(View itemView) { super(itemView); Spork.bind(this); } public void update(String text) { textView.setText(text); } @BindClick(R.id.textview) private void onClick() { \/\/ Your click-handling logic goes here } } @Override public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { LayoutInflater inflater = LayoutInflater.from(parent.getContext()); View view = inflater.inflate(R.layout.view_recyclerview_item, parent, false); return new MyViewHolder(view); } @Override public void onBindViewHolder(MyViewHolder holder, int position) { String item = items.get(position); holder.update(item); } @Override public int getItemCount() { return items.size(); } }","tags":"","url":"Android\/Examples\/RecyclerView.html"},{"title":"Service","text":"Service Introduction The following annotations are supported: @BindResource @BindComponent Example public class TestService extends Service { @BindComponent private TestComponent testComponent; public class LocalBinder extends Binder { public TestService getLocalService() { return TestService.this; } } @Override public void onCreate() { super.onCreate(); Spork.bind(this); } @Override public @Nullable IBinder onBind(Intent intent) { return new LocalBinder(); } }","tags":"","url":"Android\/Examples\/Service.html"},{"title":"View","text":"View Introduction When creating a custom view, it's best to extend a FrameLayout, because @BindLayout will inflate the specified layout into it. The following annotations are supported: @BindClick @BindView @BindLayout @BindResource @BindComponent Example @BindLayout(R.layout.view_layout_binding) public class MyView extends FrameLayout { @BindView(R.id.some_textview) private TextView textView; @BindComponent private DownloadManager downloadManager; public MyView(Context context) { super(context); \/\/ Note: Spork.bind() must be called in \/\/ all constructors that are implemented! Spork.bind(this); } @BindClick(R.id.download_button) private void onClickDownload() { downloadManager.startDownload(); } \/\/ BindClick can also pass the button that was clicked @BindClick(R.id.other_button) private void onClickOtherButton(Button otherButton) { downloadManager.startDownload(); } }","tags":"","url":"Android\/Examples\/View.html"},{"title":"Binding order","text":"Binding Order Components are bound by the order they are registered in. This means that components are bound first and any other registered annotations are bound after that. Components When Spork.bind() is called, the @BindComponent annotations are processed first. This means that when the component is bound, the @ComponentParent passed in the constructor can be acccessed, but the injection on @ComponentParent fields might not have finished. Example public class ExampleActivity extends Activity { @BindComponent private Component component; @BindView(R.id.test) private View testView; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); } public View getTestView() { return testView; } } public class Component { public Component(@ComponentParent ExampleActivity activity) { \/\/ at this point, activity.getView() will still return null } } Solution 1 Store the component parent and access its properties only by reference. public class ExampleActivity extends Activity { \/\/ ... } public class Component { private final ExampleActivity activity; public Component(@ComponentParent ExampleActivity activity) { this.activity = activity; } public void show() { \/\/ as long as show() is called after the parent's \/\/ Spork.bind() then all is fine activity.getView().setVisibility(View.VISIBLE); } } Solution 2 Cache the fields when any of the component methods are called. public class ExampleActivity extends Activity { \/\/ ... } public class Component { private final ExampleActivity activity; private View view; public Component(@ComponentParent ExampleActivity activity) { this.activity = activity; } public void show() { assureViewsCached(); view.setVisibility(View.VISIBLE); } private void assureViewsCached() { if (view == null) { view = activity.getView(); } } } Solution 3 Give your component an initializing method and call it after the parent's Spork.bind() public class ExampleActivity extends Activity { \/\/ ... @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); component.initialize(); \/\/ initialization after binding finished } \/\/ ... } public class Component { private final ExampleActivity activity; private View view; public Component(@ComponentParent ExampleActivity activity) { this.activity = activity; } public void initialize() { \/\/ Cache view view = activity.getView(); } } Inheritance When extending classes, you should only call Spork.bind() in the base class where you want to apply bindings. All derived classes will automatically get bound too. Injection for classes that apply inheritance happens from the most top-level class to the bottom level base class. class ComponentBase { public ComponentBase() { Spork.bind(this); } } class Component extends ComponentBase { @BindComponent private SomeOtherComponent someOtherComponent; \/\/ No need to call Spork.bind() because superclass handles that } class Parent { @BindComponent private Component component; public Parent() { \/\/ Component is injected and both Component and ComponentBase \/\/ annotations are processed Spork.bind(this); } }","tags":"","url":"Android\/Advanced\/Binding_order.html"},{"title":"ProGuard","text":"ProGuard ProGuard's shrinking process might remove your components, because they are instantiated by reflection instead of the regular way. To avoid this, you need to specify the classes and interfaces to keep in your proguard configuration. Example -keep class com.yourapp.components.** { *; } -keep interface com.yourapp.components.** { *; }","tags":"","url":"Android\/Advanced\/ProGuard.html"},{"title":"BindComponent","text":"@BindComponent Any class can become a component. Components need to have a default constructor available (either specified or implied) with 0 or 1 arguments. Components don't need to call Spork.bind() itself, but it is perfectly fine to do so. This is the simplest component that you could create: public class Parent { @BindComponent private Child child; public Parent() { Spork.bind(this); } } public class Child { } Base types and interfaces You can inject to any assignable type, as long as you specify the implementation. For example: @BindComponent(SomethingImplementation.class) private SomethingInterface something; Scope You can optionally specify a scope for Child by declaring in an annotation. The default scope means that a new instance of the component is created for each time it is bound somewhere. The singleton scope means that there will be at most 1 instance. @ComponentScope(ComponentScope.Scope.SINGLETON) public class Child { \/\/ ... } Parent If you want to inject the component's parent, you can add it as a constructor parameter. It is also not required to call Spork.bind() on the referenced component. It's important that you always use the @ComponentParent annotation on the parameter. public class Child { final private Parent parent; public Child(@ComponentParent Parent parent) { this.parent = parent; } } The default scope creates a new instance for each binding.","tags":"","url":"Dependency_Injection\/Annotations\/BindComponent.html"},{"title":"Component","text":"Component Introduction Spork.bind() can be used on any Object to bind components to its fields. A component can be bound directly: @BindComponent private RegularUserManager regularUserManager; Or it can be bound by specifying its interface and implementation: @BindComponent(RegularUserManager.class) private UserManager userManager; Example Services public interface UserManager { User getUser(long id); } @ComponentScope(ComponentScope.Scope.SINGLETON) \/\/ optional annotation public class RegularUserManager implements UserManager { public User getUser(long id) { \/\/ return user from database } } @ComponentScope(ComponentScope.Scope.SINGLETON) \/\/ optional annotation public class CachedUserManager implements UserManager { public User getUser(long id) { \/\/ return user from cache } } Application public class Application implements Runnable { @BindComponent(RegularUserManager.class) private UserManager regularUserManager; @BindComponent(CachedUserManager.class) private UserManager cachedUserManager; public Application() { Spork.bind(this); } @Override public void run() { \/\/ use regularUserManager and cachedUserManager } }","tags":"","url":"Dependency_Injection\/Examples\/Component.html"},{"title":"Testing","text":"Testing Spork provides basic support for unit-testing. Specifically for creating mock\/stub classes for components. Standard mocking The default implementation for mocks\/stubs with Spork is by injecting alternative classes into objects: \/\/ Create a ComponentFactory for mocking MockingComponentFactory mockingFactory = new MockingComponentFactory() .register(RegularImplementationA.class, MockedImplementationA.class) .register(RegularImplementationB.class, MockedImplementationB.class); \/\/ Assign the new ComponentFactory ComponentInstanceManager.setComponentFactory(mockingFactory); That's it! Instead of injecting RegularImplementation* classes, MockedImplementation* classes will be instantiated and injected instead! Mockito support Configuration To enable Mockito support, add the following dependency: dependencies { compile ('io.github.sporklibrary:spork-mockito:1.1.0') { exclude group: 'io.github.sporklibrary' } } Example Consider the following classes: public class Component { public int getValue() { return 1; } } public class Parent { @BindComponent private Component component; public Parent() { Spork.bind(this); } public Component getComponent() { return component; } } To start mocking, this needs to be done: \/\/ Enable mocking for the specified class(es) SporkMockito.initialize(Component.class); \/\/ This can be called multiple times to reset the mocking classes. \/\/ Alternatively, mocking can be enabled for all component classes with: \/\/ SporkMockito.initialize() \/\/ Object instantiation Parent parent = new Parent(); Component mockedComponent = parent.getComponent(); \/\/ Run Mockito tests assertEquals(&quot;mocked default value&quot;, 0, mockedComponent.getValue()); when(mockedComponent.getValue()).thenReturn(2); assertEquals(&quot;mocked overridden value&quot;, 2, mockedComponent.getValue()); Custom mocking It's possible to implement your own mocking behavior. All you need to do is implement your own ComponentFactory and implement the required methods: public class CustomMockingComponentFactory implements ComponentFactory { @Override public Object create(Class&lt;?&gt; classObject, Object parent) { return CustomMockingFramework.mock(classObject); } } All that is left is registering it: ComponentInstanceManager.setComponentFactory(customComponentFactory);","tags":"","url":"Dependency_Injection\/Testing.html"},{"title":"Creating annotations","text":"Creating Annotations Overview Spork annotations are bound through a MethodBinder and\/or FieldBinder and\/or TypeBinder. These binders are registered through a BinderManager which is accessible through Spork.getBinderManager() FieldBinder FieldBinders are used for annotations that target ElementType.FIELD. Example public class BindViewBinder implements FieldBinder&lt;BindView&gt; { @Override public Class&lt;BindView&gt; getAnnotationClass() { return BindView.class; } @Override public void bind(final Object object, final AnnotatedField&lt;BindView&gt; annotatedField) { \/\/ Internally retrieves a `View` from the `object` \/\/ by checking its type (Activity\/Fragment\/View) final @Nullable View view = resolveView(object, annotatedField); if (view == null) { throw new BindException(...); } \/\/ Set the value for the object given the AnnotatedField AnnotatedFields.set(annotatedField, object, view); } } Check out the @BindView annotation binder: BindViewBinder here. MethodBinder MethodBinders are used for annotations that target ElementType.METHOD. Example public class BindClickBinder implements MethodBinder&lt;BindClick&gt; { @Override public Class&lt;BindClick&gt; getAnnotationClass() { return BindClick.class; } @Override public void bind(final Object object, AnnotatedMethod&lt;BindClick&gt; annotatedMethod) { \/\/ Internally retrieves a 'View' from the `object` \/\/ by checking its type (Activity\/Fragment\/View) final @Nullable View view = getView(object, annotatedMethod); if (view == null) { throw new BindException(...); } \/\/ Bind the custom OnClickListener that applies Java reflection \/\/ This saves CPU-intensive reflection calls until when it's necessary view.setOnClickListener(new CustomListener(annotatedMethod, object)); } } Check out the @BindClick annotation binder: BindClickBinder here. TypeBinder TypeBinders are used for annotations that target ElementType.TYPE. Example public interface IntSettable { void setValue(int value); } public class ValueBinder implements TypeBinder&lt;BindValue&gt; { @Override public Class&lt;BindValue&gt; getAnnotationClass() { return BindValue.class; } @Override public void bind(Object object, AnnotatedType&lt;BindValue&gt; annotatedClass) { \/\/ @BindValue only works with IntSettable implementations if (!IntSettable.class.isAssignableFrom(object.getClass())) { throw new BindException(...); } \/\/ Safely convert to IntSettable IntSettable value_holder = (IntSettable)object; \/\/ Set the integer value int value = annotatedClass.getAnnotation().value(); value_holder.setValue(value); } } Check out the @BindLayout annotation binder: BindLayoutBinder here. Binder registration Single target binders For binders that only bind to a single annotation target (e.g. ElementType.FIELD, ElementType.METHOD or ElementType.TYPE). The following code demonstrates this. YourAnnotation.java @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface YourAnnotation { } YourAnnotationBinder.java class YourAnnotationBinder implements MethodBinder&lt;YourAnnotation&gt; { \/\/ implementation } Main.java Spork.getBinderManager().register(new YourAnnotationBinder()); Multi-target binders For binders that only bind to multiple annotation targets (e.g. ElementType.FIELD, ElementType.METHOD or ElementType.TYPE). The following code demonstrates this. YourAnnotation.java @Retention(RetentionPolicy.RUNTIME) @Target({ ElementType.METHOD, Element.FIELD }) public @interface YourAnnotation { } YourAnnotationBinder.java class YourAnnotationBinder implements MethodBinder&lt;YourAnnotation&gt;, FieldBinder&lt;YourAnnotation&gt; { \/\/ implementation } Main.java YourAnnotationBinder binder = new YourAnnotationBinder(); \/\/ register as MethodBinder Spork.getBinderManager().register((MethodBinder&lt;YourAnnotation&gt;)binder); \/\/ register as FieldBinder Spork.getBinderManager().register((FieldBinder&lt;YourAnnotation&gt;)binder);","tags":"","url":"Dependency_Injection\/Advanced\/Creating_annotations.html"},{"title":"Binding order","text":"Binding Order Components are bound by the order they are registered in. This means that components are bound first and any other registered annotations are bound after that. Components When Spork.bind() is called, the @BindComponent annotations are processed first. This means that when the component is bound, the @ComponentParent passed in the constructor can be acccessed, but the injection on @ComponentParent fields might not have finished. Example public class ExampleActivity extends Activity { @BindComponent private Component component; @BindView(R.id.test) private View testView; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); } public View getTestView() { return testView; } } public class Component { public Component(@ComponentParent ExampleActivity activity) { \/\/ at this point, activity.getView() will still return null } } Solution 1 Store the component parent and access its properties only by reference. public class ExampleActivity extends Activity { \/\/ ... } public class Component { private final ExampleActivity activity; public Component(@ComponentParent ExampleActivity activity) { this.activity = activity; } public void show() { \/\/ as long as show() is called after the parent's \/\/ Spork.bind() then all is fine activity.getView().setVisibility(View.VISIBLE); } } Solution 2 Cache the fields when any of the component methods are called. public class ExampleActivity extends Activity { \/\/ ... } public class Component { private final ExampleActivity activity; private View view; public Component(@ComponentParent ExampleActivity activity) { this.activity = activity; } public void show() { assureViewsCached(); view.setVisibility(View.VISIBLE); } private void assureViewsCached() { if (view == null) { view = activity.getView(); } } } Solution 3 Give your component an initializing method and call it after the parent's Spork.bind() public class ExampleActivity extends Activity { \/\/ ... @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Spork.bind(this); component.initialize(); \/\/ initialization after binding finished } \/\/ ... } public class Component { private final ExampleActivity activity; private View view; public Component(@ComponentParent ExampleActivity activity) { this.activity = activity; } public void initialize() { \/\/ Cache view view = activity.getView(); } } Inheritance When extending classes, you should only call Spork.bind() in the base class where you want to apply bindings. All derived classes will automatically get bound too. Injection for classes that apply inheritance happens from the most top-level class to the bottom level base class. class ComponentBase { public ComponentBase() { Spork.bind(this); } } class Component extends ComponentBase { @BindComponent private SomeOtherComponent someOtherComponent; \/\/ No need to call Spork.bind() because superclass handles that } class Parent { @BindComponent private Component component; public Parent() { \/\/ Component is injected and both Component and ComponentBase \/\/ annotations are processed Spork.bind(this); } }","tags":"","url":"Dependency_Injection\/Advanced\/Binding_order.html"},{"title":"ProGuard","text":"ProGuard ProGuard's shrinking process might remove your components, because they are instantiated by reflection instead of the regular way. To avoid this, you need to specify the classes and interfaces to keep in your proguard configuration. Example -keep class com.yourapp.components.** { *; } -keep interface com.yourapp.components.** { *; }","tags":"","url":"Dependency_Injection\/Advanced\/ProGuard.html"}]}